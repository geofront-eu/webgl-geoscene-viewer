<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>geocast viewer - WebGL</title>
  <meta name="description" content="Geocarve Online Viewer">
  <meta name="keywords" content="geofront,geocarve,geoscene,geocast,online,webgl,viewer">
  <meta name="viewport" content="width=device-width, user-scalable=no">
  
  <link href="css/style.css" rel="stylesheet">

  <script type="text/javascript" src="utils/js-geoscene-reader/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/js-geoscene-reader/geoscene-filereader.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>  
</head>
<script id="camera-frustum-lines-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  uniform vec4 uLineColor;

  void main(void) {
    gl_FragColor = uLineColor;
  }
</script>
<script id="camera-frustum-lines-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition;

  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;

  uniform mat4 uGeoCastMVMatrix;
  uniform mat4 uGeoCastProjMatrix;
  uniform mat4 uGeoCastMVMatrix_Inverse;
  uniform mat4 uGeoCastProjMatrix_Inverse;
  uniform vec2 uGeoCastClipRange;

  void main(void) {
    gl_Position = uViewProjMatrix * uViewMVMatrix * (uGeoCastMVMatrix * uGeoCastProjMatrix_Inverse *  vec4(aPosition.xyz, 1.0));
  }
</script>
<script id="surface-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  #define SAMPLE_SLOTS 5
  #extension GL_OES_standard_derivatives : enable

  uniform mat4 uGeocastMVPMatrix[SAMPLE_SLOTS];
  uniform sampler2D texGeocastSampler[SAMPLE_SLOTS];
  uniform float uBoundSlots;

  varying vec4 pass_discardFlag;
  varying vec4 pass_aPosition;
  varying vec3 pass_barycentricCoords;
  uniform float uShowWireframe;

  bool inFrustum(mat4 M, vec4 p) {
    vec4 Pclip = M * p;
    return abs(Pclip.x) <= Pclip.w && 
           abs(Pclip.y) <= Pclip.w && 
           0. <= abs(Pclip.z) && 
           abs(Pclip.z) <= Pclip.w;
  }

  float edgeFactor() {
    vec3 d = fwidth(pass_barycentricCoords);
    vec3 a3 = smoothstep(vec3(0.0), d*1.0, pass_barycentricCoords);
    return min(min(a3.x, a3.y), a3.z);
  }

  void main(void) {

    if(pass_discardFlag.a < 0.999)
      discard;

    if(uShowWireframe == 0.0) { // Texture lookup shading

      vec4 latticeBackground = vec4(0.1, 0.1, 0.1, 1.0); // Default to gray if no texture is present

      vec4 aPosition = pass_aPosition;

      vec4 final_color = latticeBackground;
      bool backgroundColor = true;

      for (int i = 0; i < SAMPLE_SLOTS; ++i) {
        if (float(i) >= uBoundSlots)
          break;

        if (inFrustum(uGeocastMVPMatrix[i], aPosition)) {
          // In-projector region, do a texture lookup
          vec4 Pclip = uGeocastMVPMatrix[i] * aPosition;
          vec2 texture_uv = vec2((Pclip.x + Pclip.w) / (2. * Pclip.w), (Pclip.y + Pclip.w) / (2. * Pclip.w));
          vec4 texel = texture2D(texGeocastSampler[i], texture_uv);
          
          if (backgroundColor) { // Substitute the background color if this is the first match
            backgroundColor = false;
            final_color = texel;
          } else {
            final_color = mix(final_color, texel, 0.5);
          }
        }
      }
      gl_FragColor = final_color;
    } else { // Wireframe anti-aliased shading and white fragments
      gl_FragColor.rgb = vec3(edgeFactor()*0.95);
      gl_FragColor.a = 1.0;
    }
  }
</script>
<script id="surface-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition; // Lattice data

  // Scene data
  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;
  // Floor data
  uniform mat4 uFloorMVMatrix;
  uniform mat4 uFloorProjMatrix;
  uniform mat4 uFloorMVMatrix_Inverse;
  uniform mat4 uFloorProjMatrix_Inverse;
  uniform vec2 uFloorClipRange;

  uniform sampler2D texDepthMapSampler;

  varying vec4 pass_discardFlag;
  varying vec4 pass_aPosition;
  varying vec3 pass_barycentricCoords;
  
  void main(void) {

    // Unpack from the Z-component the barycentric coords
    pass_barycentricCoords = vec3(aPosition.z == 100.0 ? 1.0 : 0.0,
                                  aPosition.z == 10.0 ? 1.0 : 0.0,
                                  aPosition.z == 1.0 ? 1.0 : 0.0);

    vec4 depth = texture2D(texDepthMapSampler, aPosition.xy);    

    vec4 depth_camspace;  // Purpose: "image" a pixel of depth Z (its view vector) into camera space
    depth_camspace = uFloorProjMatrix * vec4(0.0, 0.0, mix(-uFloorClipRange.x, -uFloorClipRange.y, depth.x), 1.);

    float model_depth = depth_camspace.z / depth_camspace.w;
    // Discard background depths
    pass_discardFlag = vec4(1.0, 1.0, 1.0, (depth.x == 1.0) ? 0.0 : 1.0);

    // Lattice has coords [0;1], this doesn't use the full screen extents of the projector [-1;1]. Rescale
    vec2 latticePos = vec2(aPosition.x, aPosition.y);
    latticePos = latticePos * 2.0 - 1.0;

    vec4 worldpos = uFloorMVMatrix * uFloorProjMatrix_Inverse * vec4(latticePos.xy,  model_depth, 1);
    pass_aPosition = worldpos;
    gl_Position = uViewProjMatrix * uViewMVMatrix * worldpos;
  }
</script>
<script id="colorpicker-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  uniform vec4 uColor;

  void main(void) {
      gl_FragColor = uColor;
  }
</script>
<script id="colorpicker-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition;

  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;

  uniform mat4 uGeoCastMVMatrix;
  uniform mat4 uGeoCastProjMatrix;
  uniform mat4 uGeoCastMVMatrix_Inverse;
  uniform mat4 uGeoCastProjMatrix_Inverse;

  void main(void) {
    gl_Position = uViewProjMatrix * uViewMVMatrix * (uGeoCastMVMatrix * uGeoCastProjMatrix_Inverse *  vec4(aPosition.xyz, 1.0));
  }
</script>
<script type="text/javascript">
    var gl; // gl instance

    // Global scene matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    var geoScene = null; // Main GeoScene object
    var currentMatchGroups = {}; // Active matchgroups
    var currentSceneFrame = 0; // Current geoscene frame (0 maps to geoScene.sequence[0])
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      var canvasContainer = document.getElementById("canvasContainer");      
      try {
        gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        canvas.width = canvasContainer.offsetWidth;
        canvas.height = canvasContainer.offsetHeight;
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        console.log("Could not initialize WebGL");
      }
      gl.getExtension('OES_standard_derivatives');

      setupGeometries();
      setupShaderPrograms();
      setupFramebuffers();
      setupInput(canvas);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);

      var geoSceneObjectReady = function(object) {
        updateLoadingProgress("Geoscene Loaded", 100);
        geoScene = object;
        currentSceneFrame = 0; // 0 maps to geoScene.sequence[0];        

        var frameCtrl = document.getElementById("numberbox_frame");
        frameCtrl.min = geoScene.sequence[0];
        frameCtrl.max = geoScene.sequence[1];
        frameCtrl.value = geoScene.sequence[0];
        document.getElementById("rangeFrame").innerHTML = "[" + geoScene.sequence[0] + ";" + geoScene.sequence[1] + "]";
        var matchgroupsDiv = document.getElementById("matchgroups_div");
        var divHtml = "";
        for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) {
          divHtml += "<label for=\"matchgroup_checkbox_" + i + "\" class=\"aligncheckbox\"><input type=\"checkbox\" " +
          "id=\"matchgroup_checkbox_" + i + "\" class=\"aligncheckbox\" onclick=\"handleMatchgroupClick(this, " + i + ");\"><span>&nbsp;MatchGroup " +
          i + "</span></label><br/>";
        }
        matchgroupsDiv.innerHTML = divHtml;

        if (geoScene.matchGroupSequence.length > 0)
          activateMatchgroup(0, true);

        generateSceneLattices();
        loadTextures();
      };

      updateLoadingProgress("Reading Geoscene", 10);
      readGeoSceneFile("data/sedan/sedan.geoscene", geoSceneObjectReady); // DEBUG - Local path for tests
      
      paintLoop();
    }

    function onResizeCanvas() {
      var canvasContainer = document.getElementById("canvasContainer");
      canvas.width = canvasContainer.offsetWidth;
      canvas.height = canvasContainer.offsetHeight;
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
      setupFramebuffers(); // Resize secondary framebuffers
    }

    function getCurrentMatchgroup() {
      return currentMatchGroup;
    }
    function increaseFrameWithBoundsChecking() { // Returns the new geoscene-range frame
      var curGeosceneFrame = currentSceneFrame + geoScene.sequence[0];
      curGeosceneFrame = Math.min(curGeosceneFrame + 1, geoScene.sequence[1]);
      currentSceneFrame = curGeosceneFrame - geoScene.sequence[0];
      return curGeosceneFrame;
    }
    function decreaseFrameWithBoundsChecking() { // Ditto
      var curGeosceneFrame = currentSceneFrame + geoScene.sequence[0];
      curGeosceneFrame = Math.max(geoScene.sequence[0], curGeosceneFrame - 1);
      currentSceneFrame = curGeosceneFrame - geoScene.sequence[0];
      return curGeosceneFrame;
    }
    function setFrameWithBoundsChecking(value) { // Ditto, input with geoscene-range frame number
      var rangeCheckedValue = Math.max(geoScene.sequence[0], Math.min(geoScene.sequence[1], value));
      currentSceneFrame = rangeCheckedValue - geoScene.sequence[0];
      return rangeCheckedValue;
    }
    function getCurrentFrameInGeosceneRange() { // Returns the geoscene-range frame
      return currentSceneFrame + geoScene.sequence[0];
    }

    var latticeGridCache = {}; // A cache for different resolution lattices

    function generateSceneLattices() {
      updateLoadingProgress("Generating Grids", 0);
      for (var i = 0; i < geoScene.geoCastZSequence.length; ++i) {
        var sizeKey = geoScene.geoCastZSequence[i].size[0] + 'x' + geoScene.geoCastZSequence[i].size[1];
        if (latticeGridCache.sizeKey == undefined) {
          latticeGridCache[sizeKey] = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[sizeKey]);
          var vbo_data = generateArbitraryDimensionLattice(geoScene.geoCastZSequence[i].size[0], geoScene.geoCastZSequence[i].size[1]);
          for (var i = 2, bc = 100; i < vbo_data.length; i += 3) { // Encode 100, 10, 1 as barycentric coords in the unused Z coord
            vbo_data[i] = bc;
            if (bc == 1)
              bc = 100;
            else
              bc /= 10;
          }
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
          latticeGridCache[sizeKey].n_of_vertices = vbo_data.length / 3; // Number of vertices to use
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
        updateLoadingProgress("Generating Grids", 100 * ((i + 1) / geoScene.geoCastZSequence.length));
      }
      updateLoadingProgress("Grids Ready", 100);
    }

    function generateArbitraryDimensionLattice(width, height) { // Generates a lattice of (width x height) vertices with
                                                                // normalized coords in the range [0;1]x[0;1]
      var vertices = new Float32Array(((2 * (width + 1 /* Last two for degenerate vertices*/)) * (height - 1)) * 3 /* xyz */ 
        - 2 * 3 /* Last row doesn't need the two degenerate vertices at the end */);
      var normalizeX = function(value) { // Normalize a value between [0;width] to the range [0;1]
        return value / width;
      }
      var normalizeY = function(value) { // Normalize a value between [0;height] to the range [0;1]
        return value / height;
      }
      for (var y = 0; y < height - 1; ++y) {
        // 1 -- 2
        // |  / |
        // | /  |
        // 5 -- 6

        var base_off = (y * (2 * (width + 1))) * 3;

        // Insert 1 and 5
        vertices[ base_off + 0 ] = normalizeX(0 + 0.5);
        vertices[ base_off + 1 ] = normalizeY(y + 0.5);
        vertices[ base_off + 2 ] = 0;

        vertices[ base_off + 3 ] = normalizeX(0 + 0.5);
        vertices[ base_off + 4 ] = normalizeY(y + 1.5);
        vertices[ base_off + 5 ] = 0;

        for (var x = 0; x < width - 1; ++x) {

           // Insert 2 and 6
           vertices[ base_off + ((x + 1 /* 1 and 5 are already in place */) * 2 * 3) + 0 ] = normalizeX(x + 1.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 1 ] = normalizeY(y + 0.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 2 ] = 0;

           vertices[ base_off + ((x + 1) * 2 * 3) + 3 ] = normalizeX(x + 1.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 4 ] = normalizeY(y + 1.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 5 ] = 0;
        }

        if (y < (height - 1) - 1) { // Do not insert the two degenerate points if we finished the last row

          // Insert two extra points to form degenerate triangles (end of row)
          vertices[ base_off + (width * 2 * 3) + 0 ] = vertices[ base_off + (width * 2 * 3) + 0 - 3 ];
          vertices[ base_off + (width * 2 * 3) + 1 ] = vertices[ base_off + (width * 2 * 3) + 1 - 3 ];
          vertices[ base_off + (width * 2 * 3) + 2 ] = vertices[ base_off + (width * 2 * 3) + 2 - 3 ];

          vertices[ base_off + (width * 2 * 3) + 3 ] = normalizeX(0 + 0.5); // Like 5
          vertices[ base_off + (width * 2 * 3) + 4 ] = normalizeY(y + 1.5);
          vertices[ base_off + (width * 2 * 3) + 5 ] = 0;
        }
      }
      return vertices;
    }

    var texturesMap = {};
    var totalNumberOfTextures = 0;
    var loadedTextures = 0;

    function updateLoadingProgress(text, value, finalize) {
      document.getElementById("loadingText").innerHTML = text;
      document.getElementById("loadingBar").value = value;
      if (finalize != undefined && finalize == true && value == 100) {
        document.getElementById("loadingText").innerHTML = "Viewer Ready";
        setTimeout(hideLoadingProgress, 3000);
      }
    }

    function hideLoadingProgress() {
      document.getElementById("loadingDiv").style.display = 'none';
    }    

    function loadTextures() {
      updateLoadingProgress("Readying Requests", 0);
      var loadTextureFromFile = function(geocastSequenceObject) {
        if (texturesMap[geocastSequenceObject.name] != undefined)
          return;
        texturesMap[geocastSequenceObject.name] = [];
        for (var i = 0; i <= geoScene.sequence[1] - geoScene.sequence[0]; ++i) {
          texturesMap[geocastSequenceObject.name].push(new Object());
          texturesMap[geocastSequenceObject.name][i] = gl.createTexture();
          texturesMap[geocastSequenceObject.name][i].image = new Image();
          texturesMap[geocastSequenceObject.name][i].safeToRender = false;
          texturesMap[geocastSequenceObject.name][i].image.onload = (function (j) {
            var index = j;
            return function() {
              gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name][index]);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texturesMap[geocastSequenceObject.name][index].image);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.bindTexture(gl.TEXTURE_2D, null);
              texturesMap[geocastSequenceObject.name][index].safeToRender = true;
              updateLoadingProgress("Loading Textures", 100 * (++loadedTextures / totalNumberOfTextures), true);
            };
          })(i);
          texturesMap[geocastSequenceObject.name][i].image.src = geocastSequenceObject.image[i]; 
        }        
      };

      var isSequenceObjectUsed = {}; // Allows fast usage checking for a sequence object
      for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) {
        geoScene.matchGroupSequence[i].matchSurfaceSequence.forEach(function(entry) {
          isSequenceObjectUsed[entry] = true;
        });
        geoScene.matchGroupSequence[i].matchCamSequence.forEach(function(entry) {
          isSequenceObjectUsed[entry] = true;
        });
      }

      totalNumberOfTextures = 0;
      geoScene.geoCastSequence.forEach(function(entry) {
        if (isSequenceObjectUsed[entry.name] == true)
          totalNumberOfTextures += entry.image.length;
      });
      geoScene.geoCastZSequence.forEach(function(entry) {
        if (isSequenceObjectUsed[entry.name] == true)
          totalNumberOfTextures += entry.image.length;
      });
      updateLoadingProgress("Loading Textures", 0);
      for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) {
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchSurfaceSequence,
          geoScene.geoCastZSequence, loadTextureFromFile, true);
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchCamSequence, 
          geoScene.geoCastSequence, loadTextureFromFile, true);
      }
    }

    var camera_frustum_lines_data;

    function setupGeometries() {
      camera_frustum_lines_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
      vbo_data = [
        1.0, 1.0, -1.0,
        1.0, 1.0, 1.0,
        -1.0, 1.0, -1.0,
        -1.0, 1.0, 1.0,
        1.0, -1.0, -1.0,
        1.0, -1.0, 1.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0, 1.0
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
      indices = [
        0, 1,
        4, 5,
        4, 0,
        5, 1,
        3, 2,
        7, 6,
        3, 7,
        2, 6,
        3, 1,
        2, 0,
        7, 5,
        6, 4
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices_length = indices.length;
      camera_frustum_lines_data.triangle_indices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.triangle_indices);
      indices = [
        // Left
        0, 1, 4,
        4, 1, 5,
        // Right
        3, 2, 7,
        7, 2, 6,
        // near plane
        6, 2, 0,
        6, 0, 4,
        // bottom
        6, 4, 7,
        7, 4, 5,
        // up
        2, 3, 1,
        2, 1, 0,
        // far plane
        5, 1, 3,
        5, 3, 7
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      camera_frustum_lines_data.triangle_indices_length = indices.length;
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      // Lattice data cannot be statically generated here - it depends on the image dimensions in the GeoScene (GeoCastZ, see @generateSceneLattices())
    }

    var cameraFrustumLinesProgram;
    var surfaceProgram;
    var colorPickerProgram;

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "camera-frustum-lines-shader-vs");
      var fragmentShader = getShader(gl, "camera-frustum-lines-shader-fs");
      cameraFrustumLinesProgram = gl.createProgram();
      gl.attachShader(cameraFrustumLinesProgram, vertexShader);
      gl.attachShader(cameraFrustumLinesProgram, fragmentShader);
      gl.linkProgram(cameraFrustumLinesProgram);
      if (!gl.getProgramParameter(cameraFrustumLinesProgram, gl.LINK_STATUS))
          console.log("Could not initialize shaders");
      gl.useProgram(cameraFrustumLinesProgram);
      cameraFrustumLinesProgram.aPosition = gl.getAttribLocation(cameraFrustumLinesProgram, "aPosition");      
      gl.enableVertexAttribArray(cameraFrustumLinesProgram.aPosition);
      cameraFrustumLinesProgram.uViewMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewMVMatrix");
      cameraFrustumLinesProgram.uViewProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix");
      cameraFrustumLinesProgram.uGeoCastProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix_Inverse");
      cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix_Inverse");
      cameraFrustumLinesProgram.uLineColor = gl.getUniformLocation(cameraFrustumLinesProgram, "uLineColor");
      
      vertexShader = getShader(gl, "surface-shader-vs");
      fragmentShader = getShader(gl, "surface-shader-fs");
      surfaceProgram = gl.createProgram();
      gl.attachShader(surfaceProgram, vertexShader);
      gl.attachShader(surfaceProgram, fragmentShader);
      gl.linkProgram(surfaceProgram);
      if (!gl.getProgramParameter(surfaceProgram, gl.LINK_STATUS))
          console.log("Could not initialize shaders");
      gl.useProgram(surfaceProgram);
      surfaceProgram.aPosition = gl.getAttribLocation(surfaceProgram, "aPosition");      
      gl.enableVertexAttribArray(surfaceProgram.aPosition);
      surfaceProgram.uViewMVMatrix = gl.getUniformLocation(surfaceProgram, "uViewMVMatrix");
      surfaceProgram.uViewProjMatrix = gl.getUniformLocation(surfaceProgram, "uViewProjMatrix");
      surfaceProgram.uFloorMVMatrix = gl.getUniformLocation(surfaceProgram, "uFloorMVMatrix");
      surfaceProgram.uFloorProjMatrix = gl.getUniformLocation(surfaceProgram, "uFloorProjMatrix");
      surfaceProgram.uFloorMVMatrix_Inverse = gl.getUniformLocation(surfaceProgram, "uFloorMVMatrix_Inverse");
      surfaceProgram.uFloorProjMatrix_Inverse = gl.getUniformLocation(surfaceProgram, "uFloorProjMatrix_Inverse");
      surfaceProgram.texDepthMapSampler = gl.getUniformLocation(surfaceProgram, "texDepthMapSampler");
      surfaceProgram.uFloorClipRange = gl.getUniformLocation(surfaceProgram, "uFloorClipRange");
      surfaceProgram.uGeocastMVPMatrix = gl.getUniformLocation(surfaceProgram, "uGeocastMVPMatrix");
      surfaceProgram.texGeocastSampler = gl.getUniformLocation(surfaceProgram, "texGeocastSampler[0]");
      surfaceProgram.uBoundSlots = gl.getUniformLocation(surfaceProgram, "uBoundSlots");
      surfaceProgram.uShowWireframe = gl.getUniformLocation(surfaceProgram, "uShowWireframe");

      vertexShader = getShader(gl, "colorpicker-shader-vs");
      fragmentShader = getShader(gl, "colorpicker-shader-fs");
      colorPickerProgram = gl.createProgram();
      gl.attachShader(colorPickerProgram, vertexShader);
      gl.attachShader(colorPickerProgram, fragmentShader);
      gl.linkProgram(colorPickerProgram);
      if (!gl.getProgramParameter(colorPickerProgram, gl.LINK_STATUS))
          alert("Could not initialize shaders");
      gl.useProgram(colorPickerProgram);
      // Bind uniforms and attributes      
      colorPickerProgram.uViewMVMatrix = gl.getUniformLocation(colorPickerProgram, "uViewMVMatrix");
      colorPickerProgram.uViewProjMatrix = gl.getUniformLocation(colorPickerProgram, "uViewProjMatrix");
      colorPickerProgram.uGeoCastMVMatrix = gl.getUniformLocation(colorPickerProgram, "uGeoCastMVMatrix");
      colorPickerProgram.uGeoCastProjMatrix = gl.getUniformLocation(colorPickerProgram, "uGeoCastProjMatrix");
      colorPickerProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(colorPickerProgram, "uGeoCastMVMatrix_Inverse");
      colorPickerProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(colorPickerProgram, "uGeoCastProjMatrix_Inverse");
      colorPickerProgram.uColor = gl.getUniformLocation(colorPickerProgram, "uColor");
      colorPickerProgram.aPosition = gl.getAttribLocation(colorPickerProgram, "aPosition");
      gl.enableVertexAttribArray(colorPickerProgram.aPosition);
    }

    var colorPickerFramebuffer;
    var colorPickerRenderTexture;

    function setupFramebuffers() {
      // Init secondary framebuffer for color picking
      colorPickerFramebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, colorPickerFramebuffer);
      colorPickerFramebuffer.width = gl.viewportWidth;
      colorPickerFramebuffer.height = gl.viewportHeight;
      // This is the only texture that is set up here because related to the framebuffer
      colorPickerRenderTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, colorPickerRenderTexture);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, colorPickerFramebuffer.width, colorPickerFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      // Attach the texture to the framebuffer
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorPickerRenderTexture, 0);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    var projectionCenter = vec3.fromValues(0, 0, 0); // The center of the projection where the camera points at all times
    var theta = 200.0; // Degrees spherical coord
    var phi = 30.0;   // Degrees spherical coord
    var sphere_d = 100.0; // Start spherical distance
    var wireframeEnabled = false;

    var mouseDown = false;
    var mouseDownElementId;
    var mouseDownAction = null; // Either "RotateScene" or "TimelineDrag"
    var dragDeltas = 0; // Accumulates timeline drag deltas from the mouse (allows a smoother scroll)
    var lastMouseX = null;
    var lastMouseY = null;

    function setupInput(canvas) {
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it      
      canvas.onwheel = handleMouseWheel;
      document.onkeydown = handleKeyDown;
      canvas.addEventListener('touchstart', onTouchStart);
      canvas.addEventListener('touchmove', onTouchMove);
      canvas.addEventListener('touchend', onTouchEnd);
    }

    var touchFingers = {};
    var startZoomDistance = -1;

    function calculateTwoTouchPointsDistance() {
      var distance = -1;
      if (Object.keys(touchFingers).length == 2) { // Calculate starting zoom distance
        var points = [];
        for (var key in touchFingers) {
          var point = [touchFingers[key].startX, touchFingers[key].startY];
          points.push(point);
        }        
        distance = Math.sqrt(
                              Math.pow(points[0][0] - points[1][0], 2) +
                              Math.pow(points[0][1] - points[1][1], 2)
                            );
      }
      return distance;
    }

    function onTouchStart(event) {
      event.preventDefault();
      for (var i = 0; i < event.changedTouches.length; ++i) {
        var touch = event.changedTouches[i];
        touchFingers[touch.identifier] = {
          startX: parseInt(touch.offsetX),
          startY: parseInt(touch.offsetY)
        }
      }
      startZoomDistance = calculateTwoTouchPointsDistance();
    }

    function onTouchMove(event) {
      console.log("Touch move");      
      if (Object.keys(touchFingers).length == 1) {
        // Rotation
        var touch = touchFingers[event.changedTouches[0].identifier];
        if (touch == undefined)
          return;
        var newX = parseInt(event.changedTouches[0].offsetX);
        var newY = parseInt(event.changedTouches[0].offsetY);
        theta += (newX - touch.startX) / 10.0;
        phi += (newY - touch.startY) / 10.0;
        if (theta >= 360.0) // Take a look at handleMouseMove() for more information
          theta = theta % 360.0;
        if (theta < 0.0)
          theta += 360.0;
        if (phi > 90.0) phi = 90.0;
        if (phi < -90.0) phi = -90.0;
        touch.startX = newX;
        touch.startY = newY;
      } else if (Object.keys(touchFingers).length == 2) {
        // Zoom by pinching
        for (var i = 0; i < event.changedTouches.length; ++i) { // Update known points
          var touch = touchFingers[event.changedTouches[i].identifier];
          if (touch != undefined) {
            touch.startX = parseInt(event.changedTouches[i].offsetX);
            touch.startY = parseInt(event.changedTouches[i].offsetY);
          }
        }
        var newZoomDistance = calculateTwoTouchPointsDistance();
        sphere_d -= (newZoomDistance - startZoomDistance) / 10.0;
        startZoomDistance = newZoomDistance;
      }
    }

    function onTouchEnd(event) {
      for (var i = 0; i < event.changedTouches.length; ++i)
        delete touchFingers[event.changedTouches[i].identifier];
    }

    function handleKeyDown(event) {
      var key = event.keyCode || event.which;
      switch (key) {
        case 39: { // Right keyboard arrow -> ++frame
          document.getElementById("numberbox_frame").value = increaseFrameWithBoundsChecking();
        } break;
        case 37: { // Left keyboard arrow -> --frame
          document.getElementById("numberbox_frame").value = decreaseFrameWithBoundsChecking();
        } break;
        case 87: { // 'w' key for wireframe
          wireframeEnabled = !wireframeEnabled;
          document.getElementById("checkbox_wireframe").checked = wireframeEnabled;
        } break;
      }
    }

    function onMouseOutOfCanvas(event) {
      var e = event.toElement || event.relatedTarget;
      if (mouseDownElementId !== "canvas") // This is not handled for arrows
        return;
      handleMouseUp(event);
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.offsetX;
      lastMouseY = event.offsetY;

      var timelineClick = executeColorPicking(lastMouseX, lastMouseY);
      if (timelineClick)
        mouseDownAction = "TimelineDrag";
      else
        mouseDownAction = "RotateScene";
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.offsetX;
      var newY = event.offsetY;
      var deltaX = newX - lastMouseX;
      var deltaY = newY - lastMouseY;

      if (mouseDownElementId == "canvas") { // Canvas handling

        if (mouseDownAction == "RotateScene") { // Scene rotation handling

          var d_theta = deltaX / 10.0;
          var d_phi   = deltaY / 10.0;

          theta += d_theta;
          if (theta >= 360.0) // Constrain theta in the [0;360] range
            theta = theta % 360.0;
          if (theta < 0.0)
            theta += 360.0; 
         
          phi += d_phi;
          if (phi > 90.0) phi = 90.0;   // Constrain phi in the [-90;90] range
          if (phi < -90.0) phi = -90.0; // to avoid up vector problems

        } else if (mouseDownAction == "TimelineDrag") { // Timeline dragging handling

          if(deltaX > 0) // Only use deltaX here
            ++dragDeltas;
          else if(deltaX < 0)
            --dragDeltas;

          if (dragDeltas > 5) {
            increaseFrameWithBoundsChecking();
            updateFrameEditBox(getCurrentFrameInGeosceneRange());
            dragDeltas = 0;
          } else if (dragDeltas < -5) {
            decreaseFrameWithBoundsChecking();
            updateFrameEditBox(getCurrentFrameInGeosceneRange());
            dragDeltas = 0;
          }

        }
      }

      lastMouseX = newX;
      lastMouseY = newY;
    }

    function handleMouseWheel(event) {
      // Get cross-browser wheel delta
      var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.deltaY || -event.detail)));
      //var delta = Math.max(-1, Math.min(1, event.wheelDelta));
 
      sphere_d += delta * -2.0;
    }

    function executeColorPicking(mouseX, mouseY) {

      updateSceneMatrices();

      gl.bindFramebuffer(gl.FRAMEBUFFER, colorPickerFramebuffer);      
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      gl.useProgram(colorPickerProgram);
      gl.uniformMatrix4fv(colorPickerProgram.uViewMVMatrix, false /* WebGL supports column-major only */, modelViewMatrix);
      gl.uniformMatrix4fv(colorPickerProgram.uViewProjMatrix, false /* WebGL supports column-major only */, perspectiveMatrix);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.triangle_indices);
      gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
      gl.vertexAttribPointer(cameraFrustumLinesProgram.aPosition, 3, gl.FLOAT, false, 0, 0);

      var baseColor = [1.0, 0.0, 0.0, 1.0];

      var drawColorFrustum = function(geocastSequenceObject, mvMatrix, pMatrix) {
         gl.uniformMatrix4fv(colorPickerProgram.uGeoCastMVMatrix, false /* WebGL supports column-major only */, 
        mvMatrix);
        gl.uniformMatrix4fv(colorPickerProgram.uGeoCastProjMatrix, false /* WebGL supports column-major only */, 
          pMatrix);
        var inverseMVMatrix = mat4.create();
        var inversePMatrix = mat4.create();
        mat4.invert(inverseMVMatrix, mvMatrix);
        mat4.invert(inversePMatrix, pMatrix);
        gl.uniformMatrix4fv(colorPickerProgram.uGeoCastMVMatrix_Inverse, false /* WebGL supports column-major only */, 
          inverseMVMatrix);      
        gl.uniformMatrix4fv(colorPickerProgram.uGeoCastProjMatrix_Inverse, false /* WebGL supports column-major only */, 
          inversePMatrix);

        gl.uniform4fv(colorPickerProgram.uColor, baseColor);

        gl.drawElements(gl.TRIANGLES, camera_frustum_lines_data.triangle_indices_length, gl.UNSIGNED_SHORT, 0);
      };
      for(var groupId in currentMatchGroups) {
        if (currentMatchGroups[groupId] == false)
          continue;
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[groupId].matchCamSequence,
          geoScene.geoCastSequence, drawColorFrustum, false);
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[groupId].matchSurfaceSequence,
          geoScene.geoCastZSequence, drawColorFrustum, false);
      }

      // Detect the sequence object associated to where the mouse clicked
      var pixel_data = new Uint8Array(4);
      // Remember that coordinates are upside down for textures
      gl.readPixels(mouseX, gl.viewportHeight - mouseY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel_data);

      // Restore original framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      if (pixel_data[0] == 0)
        return false;
      else
        return true; // Timeline
    }

    function executeActionForObjectsInSequence(matchGroupSequence, geocastSequence, actionCallback, ignoreGeocast) {
      var orthoOrPerspMatrix = function(geocastObject) {
        return (geocastObject.PerspMatrix != undefined) ? 
                geocastObject.PerspMatrix : geocastObject.OrthoMatrix;
      }
      for (var objIndex in matchGroupSequence) {
        var objName = matchGroupSequence[objIndex];
        var geoCastSequenceObject = geocastSequence.find(function(element, index, array) {
          if(element.name == objName)
            return element;
        });
        if (geoCastSequenceObject == undefined || geoCastSequenceObject == null)
          console.log("Could not find a geocast sequence object with key '" + objName + "'");
        if (ignoreGeocast == false) {
          var index = currentSceneFrame;
          if (geoCastSequenceObject.geocast.length == 1)
            index = 0; // Deals with only one geocast case
          if (geoCastSequenceObject.geocast[index].ModelviewMatrix == undefined || 
              geoCastSequenceObject.geocast[index].ModelviewMatrix == null) { // Caveat: do NOT check for the object itself (placeholders)
            continue; // Sequence object not loaded yet
          }
          var pMatrix = orthoOrPerspMatrix(geoCastSequenceObject.geocast[index]);
          actionCallback (geoCastSequenceObject, geoCastSequenceObject.geocast[index].ModelviewMatrix, pMatrix);
        } else {
          actionCallback (geoCastSequenceObject);
        }
      }
    }

    function drawCameraFrustums() {
      var drawFrustum = function(mvMatrix, pMatrix, color) {
        var inverseMVMatrix = mat4.create();
        var inversePMatrix = mat4.create();
        mat4.invert(inverseMVMatrix, mvMatrix);
        mat4.invert(inversePMatrix, pMatrix);
        gl.useProgram(cameraFrustumLinesProgram);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
        gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
        gl.vertexAttribPointer(cameraFrustumLinesProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewMVMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewProjMatrix, false, perspectiveMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix, false, pMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse, false, inverseMVMatrix);      
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse, false, inversePMatrix);
        gl.uniform4fv(cameraFrustumLinesProgram.uLineColor, color);
        gl.drawElements(gl.LINES, camera_frustum_lines_data.indices_length, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }      
      var drawSurfaceFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) { // Z surfaces
        drawFrustum (mvMatrix, pMatrix, [0.5, 0.5, 0.5, 1.0]);
      };      
      var drawCameraFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) {
        drawFrustum (mvMatrix, pMatrix, [0.8, 0.0, 0.0, 1.0]);
      };
      for(var groupId in currentMatchGroups) {
        if (currentMatchGroups[groupId] == false)
          continue;
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[groupId].matchSurfaceSequence,
          geoScene.geoCastZSequence, drawSurfaceFrustumCallback, false);
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[groupId].matchCamSequence,
          geoScene.geoCastSequence, drawCameraFrustumCallback, false);
      }
    }

    function updateSceneMatrices() {
      mat4.identity(modelViewMatrix);
      mat4.identity(perspectiveMatrix);

      // Calculate camera position (eye field) according to spherical coords
      var cameraPos = vec3.create();
      cameraPos[0] = sphere_d * Math.sin(degToRad(theta)) * Math.cos(degToRad(phi));  
      cameraPos[1] = sphere_d * Math.cos(degToRad(theta)) * Math.cos(degToRad(phi));
      cameraPos[2] = sphere_d * Math.sin(degToRad(phi));

      mat4.lookAt(modelViewMatrix, /* eye */ cameraPos, /* center */ projectionCenter, /* up */ [0, 0, 1]);
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 5000.0);
    }

    var maximumCamTexturesEverBound = 0;

    function drawSurfaces() {

      var drawSurface = function (id) {
        var matchGroupId = id;
        return function(geocastSequenceObject /* ZSurface */, mvMatrix, pMatrix) {        
          gl.useProgram(surfaceProgram);
          
          if (texturesMap[geocastSequenceObject.name][currentSceneFrame].safeToRender == false)
            return;
          var resKey = geocastSequenceObject.size[0] + 'x' + geocastSequenceObject.size[1];
          if (Object.keys(latticeGridCache).length == 0 || latticeGridCache[resKey] == undefined)
            return; // Lattice hasn't been created yet / object not ready

          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name][currentSceneFrame]);
          gl.uniform1i(surfaceProgram.texDepthMapSampler, 0);

          var matricesFloatArray = [];
          var availableTexId = 1;
          var textureUnitsToUse = [];
          var textureKeys = [];
          var detectedUnsafeToRenderTextures = false;
          var bindGeocastInfo = function(geocastSequenceObj, mvMat, pMat) {
            if (availableTexId > 15)
              console.log("Insufficient texture units");
            if(texturesMap[geocastSequenceObj.name][currentSceneFrame].safeToRender == false) {
              detectedUnsafeToRenderTextures = true;
              return;
            }
            var mvpMat = mat4.create();
            mat4.multiply(mvpMat, mvpMat, pMat);
            var mvInverseMat = mat4.create(); // (Marco): Remember that Geocarve uses inverted MVs
            mat4.invert(mvInverseMat, mvMat);
            mat4.multiply(mvpMat, mvpMat, mvInverseMat);
            matricesFloatArray.push.apply(matricesFloatArray, mvpMat);
            textureUnitsToUse.push(availableTexId);
            textureKeys.push(geocastSequenceObj.name);
            ++availableTexId;
          };
          executeActionForObjectsInSequence(
            geoScene.matchGroupSequence[matchGroupId].matchCamSequence, 
            geoScene.geoCastSequence, bindGeocastInfo, false);

          if (textureUnitsToUse.length == 0 || detectedUnsafeToRenderTextures == true)
            return; // Textures not loaded yet

          for (var i = 0; i < textureUnitsToUse.length; ++i) {
            gl.activeTexture(gl.TEXTURE0 + textureUnitsToUse[i]);
            gl.bindTexture(gl.TEXTURE_2D, texturesMap[textureKeys[i]][currentSceneFrame]);
          }
          var shaderTextureUnitsArray = textureUnitsToUse;
          if (shaderTextureUnitsArray.length < maximumCamTexturesEverBound) { // Workaround for chrome unbound texunit warnings
            Array.prototype.push.apply(shaderTextureUnitsArray, new Uint8Array(maximumCamTexturesEverBound - shaderTextureUnitsArray.length));
          } else if (shaderTextureUnitsArray.length > maximumCamTexturesEverBound) {
            maximumCamTexturesEverBound = shaderTextureUnitsArray.length;
          }
          gl.uniform1iv(surfaceProgram.texGeocastSampler, shaderTextureUnitsArray);
          gl.uniformMatrix4fv(surfaceProgram.uGeocastMVPMatrix, false, matricesFloatArray);
          gl.uniform1f(surfaceProgram.uBoundSlots, textureUnitsToUse.length);
          gl.uniform1f(surfaceProgram.uShowWireframe, wireframeEnabled == true ? 1.0 : 0.0);
          
          var inverseMVMatrix = mat4.create();
          var inversePMatrix = mat4.create();
          mat4.invert(inverseMVMatrix, mvMatrix);
          mat4.invert(inversePMatrix, pMatrix);
          gl.uniformMatrix4fv(surfaceProgram.uFloorMVMatrix, false, mvMatrix);
          gl.uniformMatrix4fv(surfaceProgram.uFloorProjMatrix, false, pMatrix);
          gl.uniformMatrix4fv(surfaceProgram.uFloorMVMatrix_Inverse, false, inverseMVMatrix);
          gl.uniformMatrix4fv(surfaceProgram.uFloorProjMatrix_Inverse, false, inversePMatrix);
          gl.uniformMatrix4fv(surfaceProgram.uViewMVMatrix, false, modelViewMatrix);
          gl.uniformMatrix4fv(surfaceProgram.uViewProjMatrix, false, perspectiveMatrix);
          var zRange = (geocastSequenceObject.geocast[currentSceneFrame].ProjRange != undefined) ? 
                        geocastSequenceObject.geocast[currentSceneFrame].ProjRange : geocastSequenceObject.geocast[currentSceneFrame].ClipRange;
          gl.uniform2fv(surfaceProgram.uFloorClipRange, zRange);

          gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[resKey]);
          gl.vertexAttribPointer(surfaceProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, latticeGridCache[resKey].n_of_vertices);
          
          gl.bindTexture(gl.TEXTURE_2D, null);
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, null);
          for (var i = 0; i < textureUnitsToUse.length; ++i) {
            gl.activeTexture(gl.TEXTURE0 + textureUnitsToUse[i]);
            gl.bindTexture(gl.TEXTURE_2D, null);
          }
          gl.useProgram(null);
        };
      };
      for(var groupId in currentMatchGroups) {
        if (currentMatchGroups[groupId] == false)
          continue;
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[groupId].matchSurfaceSequence,
          geoScene.geoCastZSequence, drawSurface(groupId), false);
      }
    }

    function drawScene() {
      if (geoScene == null)
        return; // Still loading..

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

      updateSceneMatrices();
      drawCameraFrustums();
      drawSurfaces();
    }

    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }

    // UI related routines
    function activateMatchgroup(id, activate) {
      if (activate) {
        document.getElementById("matchgroup_checkbox_" + id).checked = true;
        currentMatchGroups[id] = true;
      } else {
        document.getElementById("matchgroup_checkbox_" + id).checked = false;
        currentMatchGroups[id] = false;
      }
    }

    function handleWireframeClick(checkbox) {
      wireframeEnabled = checkbox.checked;
    }

    function handleMatchgroupClick(checkbox, id) {
      if (checkbox.checked == true)
        activateMatchgroup(id, true);
      else
        activateMatchgroup(id, false);
    }

    function handleFrameChange(inputbox) {      
      var rangeCheckedValue = setFrameWithBoundsChecking(parseInt(inputbox.value));
      inputbox.value = rangeCheckedValue;
    }

    function updateFrameEditBox(value) {
      document.getElementById("numberbox_frame").value = value;
    }
  </script>
<body onload="webGLStart();" onresize="onResizeCanvas();">
  <div class="content-div">
    <div class="header">
      <img src="img/geofront.svg" class="geofront-img"/>
    </div>
    <div id="canvasContainer" class="container">
      <div id="controlsDiv">
        <label for="wireframe_checkbox" class="aligncheckbox"><input type="checkbox" id="checkbox_wireframe" class="aligncheckbox" onclick="handleWireframeClick(this);"/><span>&nbsp;Toggle Wireframe</span></label><br/>
        <p>Frame <span id="rangeFrame">[]</span>&nbsp;&nbsp;<input id="numberbox_frame" class="numberbox" type="number" value="0" min="0" max="999" onchange="handleFrameChange(this);"/></p>
        <p>Active MatchGroups<br/><div id="matchgroups_div"></div></p>        
      </div>
      <div id="loadingDiv"><label for="loadingBar"><span id="loadingText"></span>&nbsp;&nbsp;<progress id="loadingBar" value="0" max="100"></progress></label></div>
      <canvas id="canvas"></canvas>
    </div>    
    <div class="footer">
      <div class="geofront-credits">
        <div id="label">geocast viewer - WebGL</div>
      </div>
    </div>
  </div>
</body>
</html>