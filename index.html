<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Geocarve WebGL Viewer</title>
  <script type="text/javascript" src="utils/js-geoscene-reader/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/js-geoscene-reader/geoscene-filereader.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>  
</head>
<script id="camera-frustum-lines-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  uniform vec4 uLineColor;

  void main(void) {
    gl_FragColor = uLineColor;
  }
</script>
<script id="camera-frustum-lines-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition;

  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;

  uniform mat4 uGeoCastMVMatrix;
  uniform mat4 uGeoCastProjMatrix;
  uniform mat4 uGeoCastMVMatrix_Inverse;
  uniform mat4 uGeoCastProjMatrix_Inverse;
  uniform vec2 uGeoCastClipRange;

  void main(void) {
    gl_Position = uViewProjMatrix * uViewMVMatrix * (uGeoCastMVMatrix * uGeoCastProjMatrix_Inverse *  vec4(aPosition.xyz, 1.0));
  }
</script>
<script id="surface-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  #define SAMPLE_SLOTS 5

  uniform mat4 uGeocastMVPMatrix[SAMPLE_SLOTS];
  uniform sampler2D texGeocastSampler[SAMPLE_SLOTS];
  uniform float boundSlots;

  varying vec4 pass_discardFlag;
  varying vec4 pass_aPosition;

  bool inFrustum(mat4 M, vec3 p) {
    vec4 Pclip = M * vec4(p, 1.);
    return abs(Pclip.x) < Pclip.w && 
           abs(Pclip.y) < Pclip.w && 
           0. < Pclip.z && 
           Pclip.z < Pclip.w;
  }

  void main(void) {
    if(pass_discardFlag.a < 0.999)
      discard;

    vec4 latticeBackground = vec4(0.1, 0.1, 0.1, 1.0); // Default to gray if no texture is present

    vec4 aPosition = vec4(pass_aPosition.xyz / pass_aPosition.w, 1.0);

    vec4 final_color = latticeBackground;
    bool backgroundColor = true;

    for (int i = 0; i < SAMPLE_SLOTS; ++i) {
      if (float(i) >= boundSlots)
        break;

      if (inFrustum(uGeocastMVPMatrix[i], aPosition.xyz)) {
        // In-projector region, do a texture lookup
        vec4 Pclip = uGeocastMVPMatrix[i] * aPosition;
        vec2 texture_uv = vec2((Pclip.x + Pclip.w) / (2. * Pclip.w), (Pclip.y + Pclip.w) / (2. * Pclip.w));
        vec4 texel = texture2D(texGeocastSampler[i], texture_uv);
        
        if (backgroundColor) { // Substitute the background color if this is the first match
          backgroundColor = false;
          final_color = texel;
        } else {
          final_color = mix(final_color, texel, 0.5);
        }
      }
    }
    gl_FragColor = final_color;
  }
</script>
<script id="surface-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition; // Lattice data

  // Scene data
  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;
  // Floor data
  uniform mat4 uFloorMVMatrix;
  uniform mat4 uFloorProjMatrix;
  uniform mat4 uFloorMVMatrix_Inverse;
  uniform mat4 uFloorProjMatrix_Inverse;
  uniform vec2 uFloorClipRange;

  uniform sampler2D texDepthMapSampler;

  varying vec4 pass_discardFlag;
  varying vec4 pass_aPosition;
  
  void main(void) {

    vec4 depth = texture2D(texDepthMapSampler, aPosition.xy);    

    vec4 depth_camspace;  // purpose: "image" a pixel of depth Z (its view vector) into camera space
    depth_camspace = uFloorProjMatrix * vec4(0.0, 0.0, mix(-uFloorClipRange.x, -uFloorClipRange.y, depth.x), 1);

    float model_depth = depth_camspace.z / depth_camspace.w;
    // Discard background depths
    pass_discardFlag = vec4(1.0, 1.0, 1.0, (depth.x == 1.0) ? 0.0 : 1.0);

    // Lattice has coords [0;1], this doesn't use the full screen extents of the projector [-1;1]. Rescale
    vec2 latticePos = vec2(aPosition.x, aPosition.y);
    latticePos = latticePos * 2.0 - 1.0;

    vec4 worldpos = uFloorMVMatrix * uFloorProjMatrix_Inverse * vec4(latticePos.xy,  model_depth, 1);
    pass_aPosition = worldpos;
    gl_Position = uViewProjMatrix * uViewMVMatrix * worldpos;
  }
</script>
<script type="text/javascript">
    var gl; // gl instance

    // Global scene matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    var geoScene = null; // Main GeoScene object
    var currentMatchGroup = 0; // Current matchgroup index
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        console.log("Could not initialize WebGL");
      }

      setupGeometries();
      setupShaderPrograms();      
      setupInput(canvas);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);

      var geoSceneObjectReady = function(object) {
        geoScene = object;
        generateSceneLattices();
        loadTextures();
      };      
      readGeoSceneFile("data/Raw.geoscene", geoSceneObjectReady); // DEBUG - Local path for tests
      
      paintLoop();
    }

    var latticeGridCache = {}; // A cache for different resolution lattices

    function generateSceneLattices() {
      for (var i = 0; i < geoScene.geoCastZSequence.length; ++i) {
        var sizeKey = geoScene.geoCastZSequence[i].size[0] + 'x' + geoScene.geoCastZSequence[i].size[1];
        if (latticeGridCache.sizeKey == undefined) {
          latticeGridCache[sizeKey] = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[sizeKey]);
          var vbo_data = generateArbitraryDimensionLattice(geoScene.geoCastZSequence[i].size[0], geoScene.geoCastZSequence[i].size[1]);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
          latticeGridCache[sizeKey].n_of_vertices = vbo_data.length / 3; // Number of vertices to use
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
      }      
    }

    function generateArbitraryDimensionLattice(width, height) { // Generates a lattice of (width x height) vertices with
                                                                // normalized coords in the range [0;1]x[0;1]
      var vertices = new Float32Array(((2 * (width + 1 /* Last two for degenerate vertices*/)) * height) * 3 /* xyz */);
      var normalizeX = function(value) { // Normalize a value between [0;width] to the range [0;1]
        return value / width;
      }
      var normalizeY = function(value) { // Normalize a value between [0;height] to the range [0;1]
        return value / height;
      }
      for (var y = 0; y < height - 1; ++y) {
        // 1 -- 2
        // |  / |
        // | /  |
        // 5 -- 6

        var base_off = (y * (2 * (width + 1))) * 3;

        // Insert 1 and 5
        vertices[ base_off + 0 ] = normalizeX(0 + 0.5);
        vertices[ base_off + 1 ] = normalizeY(y + 0.5);
        vertices[ base_off + 2 ] = 0;

        vertices[ base_off + 3 ] = normalizeX(0 + 0.5);
        vertices[ base_off + 4 ] = -normalizeY(y + 1.5);
        vertices[ base_off + 5 ] = 0;

        for (var x = 0; x < width - 1; ++x) {

           // Insert 2 and 6
           vertices[ base_off + (x * 2 * 3) + 0 ] = normalizeX(x + 1.5);
           vertices[ base_off + (x * 2 * 3) + 1 ] = normalizeY(y + 0.5);
           vertices[ base_off + (x * 2 * 3) + 2 ] = 0;

           vertices[ base_off + (x * 2 * 3) + 3 ] = normalizeX(x + 1.5);
           vertices[ base_off + (x * 2 * 3) + 4 ] = normalizeY(y + 1.5);
           vertices[ base_off + (x * 2 * 3) + 5 ] = 0;
        }

        // Insert two extra points to form degenerate triangles (end of row)
        vertices[ base_off + (width * 2 * 3) + 0 ] = vertices[ base_off + (width * 2 * 3) + 0 - 3 ];
        vertices[ base_off + (width * 2 * 3) + 1 ] = vertices[ base_off + (width * 2 * 3) + 1 - 3 ];
        vertices[ base_off + (width * 2 * 3) + 2 ] = vertices[ base_off + (width * 2 * 3) + 2 - 3 ];

        vertices[ base_off + (width * 2 * 3) + 3 ] = normalizeX(0 + 0.5);
        vertices[ base_off + (width * 2 * 3) + 4 ] = normalizeY(y + 2.5);
        vertices[ base_off + (width * 2 * 3) + 5 ] = 0;
      }
      return vertices;
    }

    var texturesMap = {};

    function loadTextures() {
      var loadTextureFromFile = function(geocastSequenceObject) {
        texturesMap[geocastSequenceObject.name] = gl.createTexture();
        texturesMap[geocastSequenceObject.name].image = new Image();
        texturesMap[geocastSequenceObject.name].safeToRender = false;
        texturesMap[geocastSequenceObject.name].image.onload = function () {
          gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name]);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texturesMap[geocastSequenceObject.name].image);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.bindTexture(gl.TEXTURE_2D, null);
          texturesMap[geocastSequenceObject.name].safeToRender = true;
        }
        texturesMap[geocastSequenceObject.name].image.src = geocastSequenceObject.image;
      };
      for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) {
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchSurfaceSequence,
          geoScene.geoCastZSequence, loadTextureFromFile, true);
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchCamSequence, 
          geoScene.geoCastSequence, loadTextureFromFile, true);
      }
    }

    var camera_frustum_lines_data;

    function setupGeometries() {
      camera_frustum_lines_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
      vbo_data = [
        1.0, 1.0, -1.0,
        1.0, 1.0, 1.0,
        -1.0, 1.0, -1.0,
        -1.0, 1.0, 1.0,
        1.0, -1.0, -1.0,
        1.0, -1.0, 1.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0, 1.0
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
      indices = [
        0, 1,
        4, 5,
        4, 0,
        5, 1,
        3, 2,
        7, 6,
        3, 7,
        2, 6,
        3, 1,
        2, 0,
        7, 5,
        6, 4
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices_length = indices.length;
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      // Lattice data cannot be statically generated here - it depends on the image dimensions in the GeoScene (GeoCastZ, see @generateSceneLattices())
    }

    var cameraFrustumLinesProgram;
    var surfaceProgram;

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "camera-frustum-lines-shader-vs");
      var fragmentShader = getShader(gl, "camera-frustum-lines-shader-fs");
      cameraFrustumLinesProgram = gl.createProgram();
      gl.attachShader(cameraFrustumLinesProgram, vertexShader);
      gl.attachShader(cameraFrustumLinesProgram, fragmentShader);
      gl.linkProgram(cameraFrustumLinesProgram);
      if (!gl.getProgramParameter(cameraFrustumLinesProgram, gl.LINK_STATUS))
          console.log("Could not initialize shaders");
      gl.useProgram(cameraFrustumLinesProgram);
      cameraFrustumLinesProgram.aPosition = gl.getAttribLocation(cameraFrustumLinesProgram, "aPosition");      
      gl.enableVertexAttribArray(cameraFrustumLinesProgram.aPosition);
      cameraFrustumLinesProgram.uViewMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewMVMatrix");
      cameraFrustumLinesProgram.uViewProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix");
      cameraFrustumLinesProgram.uGeoCastProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix_Inverse");
      cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix_Inverse");
      cameraFrustumLinesProgram.uLineColor = gl.getUniformLocation(cameraFrustumLinesProgram, "uLineColor");
      
      vertexShader = getShader(gl, "surface-shader-vs");
      fragmentShader = getShader(gl, "surface-shader-fs");
      surfaceProgram = gl.createProgram();
      gl.attachShader(surfaceProgram, vertexShader);
      gl.attachShader(surfaceProgram, fragmentShader);
      gl.linkProgram(surfaceProgram);
      if (!gl.getProgramParameter(surfaceProgram, gl.LINK_STATUS))
          console.log("Could not initialize shaders");
      gl.useProgram(surfaceProgram);
      surfaceProgram.aPosition = gl.getAttribLocation(surfaceProgram, "aPosition");      
      gl.enableVertexAttribArray(surfaceProgram.aPosition);
      surfaceProgram.uViewMVMatrix = gl.getUniformLocation(surfaceProgram, "uViewMVMatrix");
      surfaceProgram.uViewProjMatrix = gl.getUniformLocation(surfaceProgram, "uViewProjMatrix");
      surfaceProgram.uFloorMVMatrix = gl.getUniformLocation(surfaceProgram, "uFloorMVMatrix");
      surfaceProgram.uFloorProjMatrix = gl.getUniformLocation(surfaceProgram, "uFloorProjMatrix");
      surfaceProgram.uFloorMVMatrix_Inverse = gl.getUniformLocation(surfaceProgram, "uFloorMVMatrix_Inverse");
      surfaceProgram.uFloorProjMatrix_Inverse = gl.getUniformLocation(surfaceProgram, "uFloorProjMatrix_Inverse");
      surfaceProgram.texDepthMapSampler = gl.getUniformLocation(surfaceProgram, "texDepthMapSampler");
      surfaceProgram.uFloorClipRange = gl.getUniformLocation(surfaceProgram, "uFloorClipRange");
      surfaceProgram.uGeocastMVPMatrix = gl.getUniformLocation(surfaceProgram, "uGeocastMVPMatrix");
      surfaceProgram.texGeocastSampler = gl.getUniformLocation(surfaceProgram, "texGeocastSampler[0]");
      surfaceProgram.boundSlots = gl.getUniformLocation(surfaceProgram, "boundSlots");
    }

    var projectionCenter = vec3.fromValues(0, 0, 0); // The center of the projection where the camera points at all times
    var theta = 200.0; // Degrees spherical coord
    var phi = 30.0;   // Degrees spherical coord
    var sphere_d = 500.0; // Start spherical distance

    var mouseDown = false;
    var mouseDownElementId;
    var lastMouseX = null;
    var lastMouseY = null;

    function setupInput(canvas) {
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it
      canvas.onwheel = handleMouseWheel;
      document.onkeydown = handleKeyDown;
    }

    function handleKeyDown(event) {
      var key = event.keyCode || event.which;
      switch (key) {
        case 39: { // Right keyboard arrow
          currentMatchGroup = Math.min(currentMatchGroup + 1, geoScene.matchGroupSequence.length - 1);
        } break;
        case 37: { // Left keyboard arrow
          currentMatchGroup = Math.max(0, currentMatchGroup - 1);
        } break;
      }
    }

    function onMouseOutOfCanvas(event) {
      var e = event.toElement || event.relatedTarget;
      if (mouseDownElementId !== "canvas") // This is not handled for arrows
        return;
      handleMouseUp(event);
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.clientX;
      var newY = event.clientY;
      var deltaX = newX - lastMouseX;
      var deltaY = newY - lastMouseY;

      if (mouseDownElementId == "canvas") { // Canvas handling
        var d_theta = deltaX / 10.0;
        var d_phi   = deltaY / 10.0;

        theta += d_theta;
        if (theta >= 360.0) // Constrain theta in the [0;360] range
          theta = theta % 360.0;
        if (theta < 0.0)
          theta += 360.0; 
       
        phi += d_phi;
        if (phi > 90.0) phi = 90.0;   // Constrain phi in the [-90;90] range
        if (phi < -90.0) phi = -90.0; // to avoid up vector problems
      }

      lastMouseX = newX;
      lastMouseY = newY;
    }

    function handleMouseWheel(event) {
      // Get cross-browser wheel delta
      var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.deltaY || -event.detail)));
      //var delta = Math.max(-1, Math.min(1, event.wheelDelta));
 
      sphere_d += delta * -2.0;
    }

    function executeActionForObjectsInSequence(matchGroupSequence, geocastSequence, actionCallback, ignoreGeocast) {
      var orthoOrPerspMatrix = function(geocastObject) {
        return (geocastObject.PerspMatrix != undefined) ? 
                geocastObject.PerspMatrix : geocastObject.OrthoMatrix;
      }
      for (var objIndex in matchGroupSequence) {
        var objName = matchGroupSequence[objIndex];
        var geoCastSequenceObject = geocastSequence.find(function(element, index, array) {
          if(element.name == objName)
            return element;
        });
        if (geoCastSequenceObject == undefined || geoCastSequenceObject == null)
          console.log("Could not find a geocast sequence object with key '" + objName + "'");
        if (ignoreGeocast == false) {
          if (geoCastSequenceObject.geocast == undefined || geoCastSequenceObject.geocast == null) {
            continue; // Sequence object not loaded yet
          }
          var pMatrix = orthoOrPerspMatrix(geoCastSequenceObject.geocast);
          actionCallback (geoCastSequenceObject, geoCastSequenceObject.geocast.ModelviewMatrix, pMatrix);
        } else {
          actionCallback (geoCastSequenceObject);
        }
      }
    }

    function drawCameraFrustums() {
      var drawFrustum = function(mvMatrix, pMatrix, color) {
        var inverseMVMatrix = mat4.create();
        var inversePMatrix = mat4.create();
        mat4.invert(inverseMVMatrix, mvMatrix);
        mat4.invert(inversePMatrix, pMatrix);
        gl.useProgram(cameraFrustumLinesProgram);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
        gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
        gl.vertexAttribPointer(cameraFrustumLinesProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewMVMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewProjMatrix, false, perspectiveMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix, false, pMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse, false, inverseMVMatrix);      
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse, false, inversePMatrix);
        gl.uniform4fv(cameraFrustumLinesProgram.uLineColor, color);
        gl.drawElements(gl.LINES, camera_frustum_lines_data.indices_length, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }      
      // Gain all ZSequence objects and draw them
      var drawSurfaceFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) {
        drawFrustum (mvMatrix, pMatrix, [0.5, 0.5, 0.5, 1.0]);
      };
      executeActionForObjectsInSequence(
        geoScene.matchGroupSequence[currentMatchGroup].matchSurfaceSequence,
        geoScene.geoCastZSequence, drawSurfaceFrustumCallback, false);
      var drawCameraFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) {
        drawFrustum (mvMatrix, pMatrix, [0.8, 0.0, 0.0, 1.0]);
      };
      executeActionForObjectsInSequence(
        geoScene.matchGroupSequence[currentMatchGroup].matchCamSequence, 
        geoScene.geoCastSequence, drawCameraFrustumCallback, false);
    }

    function updateSceneMatrices() {
      mat4.identity(modelViewMatrix);
      mat4.identity(perspectiveMatrix);

      // Calculate camera position (eye field) according to spherical coords
      var cameraPos = vec3.create();
      cameraPos[0] = sphere_d * Math.sin(degToRad(theta)) * Math.cos(degToRad(phi));  
      cameraPos[1] = sphere_d * Math.cos(degToRad(theta)) * Math.cos(degToRad(phi));
      cameraPos[2] = sphere_d * Math.sin(degToRad(phi));

      mat4.lookAt(modelViewMatrix, /* eye */ cameraPos, /* center */ projectionCenter, /* up */ [0, 0, 1]);
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 5000.0);
    }

    function drawSurfaces() {

      var drawSurface = function(geocastSequenceObject /* ZSurface */, mvMatrix, pMatrix) {        
        gl.useProgram(surfaceProgram);
        
        if (texturesMap[geocastSequenceObject.name].safeToRender == false)
          return;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name]);
        gl.uniform1i(surfaceProgram.texDepthMapSampler, 0);

        var matricesFloatArray = [];
        var availableTexId = 1;
        var textureUnitsToUse = [];
        var textureKeys = [];
        var bindGeocastInfo = function(geocastSequenceObj, mvMat, pMat) {
          if (availableTexId > 15)
            console.log("Insufficient texture units");
          if(texturesMap[geocastSequenceObj.name].safeToRender == false)
            return;
          var mvpMat = mat4.create();
          mat4.multiply(mvpMat, mvpMat, pMat);
          var mvInverseMat = mat4.create(); // (Marco): Remember that Geocarve uses inverted MVs
          mat4.invert(mvInverseMat, mvMat);
          mat4.multiply(mvpMat, mvpMat, mvInverseMat);
          matricesFloatArray.push.apply(matricesFloatArray, mvpMat);
          textureUnitsToUse.push(availableTexId);
          textureKeys.push(geocastSequenceObj.name);
          ++availableTexId;
        };
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[currentMatchGroup].matchCamSequence, 
          geoScene.geoCastSequence, bindGeocastInfo, false);

        for (var i = 0; i < textureUnitsToUse.length; ++i) {
          gl.activeTexture(gl.TEXTURE0 + textureUnitsToUse[i]);
          gl.bindTexture(gl.TEXTURE_2D, texturesMap[textureKeys[i]]);
        }
        gl.uniform1iv(surfaceProgram.texGeocastSampler, textureUnitsToUse);
        gl.uniformMatrix4fv(surfaceProgram.uGeocastMVPMatrix, false, matricesFloatArray);
        gl.uniform1fv(surfaceProgram.boundSlots, [textureUnitsToUse.length]);
        
        var inverseMVMatrix = mat4.create();
        var inversePMatrix = mat4.create();
        mat4.invert(inverseMVMatrix, mvMatrix);
        mat4.invert(inversePMatrix, pMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorMVMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorProjMatrix, false, pMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorMVMatrix_Inverse, false, inverseMVMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorProjMatrix_Inverse, false, inversePMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uViewMVMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uViewProjMatrix, false, perspectiveMatrix);
        var zRange = (geocastSequenceObject.geocast.ProjRange != undefined) ? 
                      geocastSequenceObject.geocast.ProjRange : geocastSequenceObject.geocast.ClipRange;
        gl.uniform2fv(surfaceProgram.uFloorClipRange, zRange);

        var resKey = geocastSequenceObject.size[0] + 'x' + geocastSequenceObject.size[1];
        if (Object.keys(latticeGridCache).length == 0 || latticeGridCache[resKey] == undefined)
          return; // Lattice hasn't been created yet / object not ready
        gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[resKey]);
        gl.vertexAttribPointer(surfaceProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, latticeGridCache[resKey].n_of_vertices);
        
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      };
      executeActionForObjectsInSequence(
        geoScene.matchGroupSequence[currentMatchGroup].matchSurfaceSequence, 
        geoScene.geoCastZSequence, drawSurface, false);
    }

    function drawScene() {
      if (geoScene == null)
        return; // Still loading..

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

      updateSceneMatrices();
      drawCameraFrustums();
      drawSurfaces();
    }

    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }
  </script>
<body onload="webGLStart();">
  <canvas id="canvas"  width="1200" height="800"></canvas>
</body>
</html>