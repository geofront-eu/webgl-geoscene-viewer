<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Geocarve WebGL Viewer</title>
  <meta name="description" content="Geocarve Online Viewer">
  <meta name="keywords" content="geofront,geocarve,geoscene,geocast,online,webgl,viewer">
  <meta name="viewport" content="width=device-width, user-scalable=no">
  
  <link href="css/style.css" rel="stylesheet">

  <script type="text/javascript" src="utils/js-geoscene-reader/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/js-geoscene-reader/geoscene-filereader.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>  
</head>
<script id="camera-frustum-lines-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  uniform vec4 uLineColor;

  void main(void) {
    gl_FragColor = uLineColor;
  }
</script>
<script id="camera-frustum-lines-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition;

  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;

  uniform mat4 uGeoCastMVMatrix;
  uniform mat4 uGeoCastProjMatrix;
  uniform mat4 uGeoCastMVMatrix_Inverse;
  uniform mat4 uGeoCastProjMatrix_Inverse;
  uniform vec2 uGeoCastClipRange;

  void main(void) {
    gl_Position = uViewProjMatrix * uViewMVMatrix * (uGeoCastMVMatrix * uGeoCastProjMatrix_Inverse *  vec4(aPosition.xyz, 1.0));
  }
</script>
<script id="surface-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  #define SAMPLE_SLOTS 5
  #extension GL_OES_standard_derivatives : enable

  uniform mat4 uGeocastMVPMatrix[SAMPLE_SLOTS];
  uniform sampler2D texGeocastSampler[SAMPLE_SLOTS];
  uniform float uBoundSlots;

  varying vec4 pass_discardFlag;
  varying vec4 pass_aPosition;
  varying vec3 pass_barycentricCoords;
  uniform float uShowWireframe;

  bool inFrustum(mat4 M, vec4 p) {
    vec4 Pclip = M * p;
    return abs(Pclip.x) <= Pclip.w && 
           abs(Pclip.y) <= Pclip.w && 
           0. <= abs(Pclip.z) && 
           abs(Pclip.z) <= Pclip.w;
  }

  float edgeFactor() {
    vec3 d = fwidth(pass_barycentricCoords);
    vec3 a3 = smoothstep(vec3(0.0), d*1.5, pass_barycentricCoords);
    return min(min(a3.x, a3.y), a3.z);
  }

  void main(void) {

    if(pass_discardFlag.a < 0.999)
      discard;

    if(uShowWireframe == 0.0) { // Texture lookup shading

      vec4 latticeBackground = vec4(0.1, 0.1, 0.1, 1.0); // Default to gray if no texture is present

      vec4 aPosition = pass_aPosition;

      vec4 final_color = latticeBackground;
      bool backgroundColor = true;

      for (int i = 0; i < SAMPLE_SLOTS; ++i) {
        if (float(i) >= uBoundSlots)
          break;

        if (inFrustum(uGeocastMVPMatrix[i], aPosition)) {
          // In-projector region, do a texture lookup
          vec4 Pclip = uGeocastMVPMatrix[i] * aPosition;
          vec2 texture_uv = vec2((Pclip.x + Pclip.w) / (2. * Pclip.w), (Pclip.y + Pclip.w) / (2. * Pclip.w));
          vec4 texel = texture2D(texGeocastSampler[i], texture_uv);
          
          if (backgroundColor) { // Substitute the background color if this is the first match
            backgroundColor = false;
            final_color = texel;
          } else {
            final_color = mix(final_color, texel, 0.5);
          }
        }
      }
      gl_FragColor = final_color;
    } else { // Wireframe anti-aliased shading and white fragments
      gl_FragColor.rgb = vec3(edgeFactor()*0.95);
      gl_FragColor.a = 1.0;
    }
  }
</script>
<script id="surface-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition; // Lattice data

  // Scene data
  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;
  // Floor data
  uniform mat4 uFloorMVMatrix;
  uniform mat4 uFloorProjMatrix;
  uniform mat4 uFloorMVMatrix_Inverse;
  uniform mat4 uFloorProjMatrix_Inverse;
  uniform vec2 uFloorClipRange;

  uniform sampler2D texDepthMapSampler;

  varying vec4 pass_discardFlag;
  varying vec4 pass_aPosition;
  varying vec3 pass_barycentricCoords;
  
  void main(void) {

    // Unpack from the Z-component the barycentric coords
    pass_barycentricCoords = vec3(aPosition.z == 100.0 ? 1.0 : 0.0,
                                  aPosition.z == 10.0 ? 1.0 : 0.0,
                                  aPosition.z == 1.0 ? 1.0 : 0.0);

    vec4 depth = texture2D(texDepthMapSampler, aPosition.xy);    

    vec4 depth_camspace;  // purpose: "image" a pixel of depth Z (its view vector) into camera space
    depth_camspace = uFloorProjMatrix * vec4(0.0, 0.0, mix(-uFloorClipRange.x, -uFloorClipRange.y, depth.x), 1.);

    float model_depth = depth_camspace.z / depth_camspace.w;
    // Discard background depths
    pass_discardFlag = vec4(1.0, 1.0, 1.0, (depth.x == 1.0) ? 0.0 : 1.0);

    // Lattice has coords [0;1], this doesn't use the full screen extents of the projector [-1;1]. Rescale
    vec2 latticePos = vec2(aPosition.x, aPosition.y);
    latticePos = latticePos * 2.0 - 1.0;

    vec4 worldpos = uFloorMVMatrix * uFloorProjMatrix_Inverse * vec4(latticePos.xy,  model_depth, 1);
    pass_aPosition = worldpos;
    gl_Position = uViewProjMatrix * uViewMVMatrix * worldpos;
  }
</script>
<script type="text/javascript">
    var gl; // gl instance

    // Global scene matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    var geoScene = null; // Main GeoScene object
    var currentMatchGroup = 0; // Current matchgroup index
    var currentSceneFrame = 0; // Current geoscene frame
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      var canvasContainer = document.getElementById("canvasContainer");      
      try {
        gl = canvas.getContext("experimental-webgl");
        canvas.width = canvasContainer.offsetWidth;
        canvas.height = canvasContainer.offsetHeight;
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        console.log("Could not initialize WebGL");
      }
      gl.getExtension('OES_standard_derivatives');

      setupGeometries();
      setupShaderPrograms();      
      setupInput(canvas);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);

      var geoSceneObjectReady = function(object) {
        geoScene = object;
        currentSceneFrame = geoScene.sequence[0];
        var frameCtrl = document.getElementById("numberbox_frame");
        frameCtrl.setAttribute("min", geoScene.sequence[0]);
        frameCtrl.setAttribute("max", geoScene.sequence[1]);
        frameCtrl.setAttribute("value", geoScene.sequence[0]);
        document.getElementById("rangeFrame").innerHTML = "[" + geoScene.sequence[0] + ";" + geoScene.sequence[1] + "]";
        var matchgroupCtrl = document.getElementById("numberbox_matchgroup");
        matchgroupCtrl.setAttribute("min", 0);
        matchgroupCtrl.setAttribute("max", geoScene.matchGroupSequence.length - 1);
        matchgroupCtrl.setAttribute("value", 0);
        document.getElementById("rangeMatchgroup").innerHTML = "[0;" + (geoScene.matchGroupSequence.length - 1) + "]";
        generateSceneLattices();
        loadTextures();
      };      
      readGeoSceneFile("data/Raw.geoscene", geoSceneObjectReady); // DEBUG - Local path for tests
      
      paintLoop();
    }

    function onResizeCanvas() {
      var canvasContainer = document.getElementById("canvasContainer");
      canvas.width = canvasContainer.offsetWidth;
      canvas.height = canvasContainer.offsetHeight;
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
    }

    var latticeGridCache = {}; // A cache for different resolution lattices

    function generateSceneLattices() {
      for (var i = 0; i < geoScene.geoCastZSequence.length; ++i) {
        var sizeKey = geoScene.geoCastZSequence[i].size[0] + 'x' + geoScene.geoCastZSequence[i].size[1];
        if (latticeGridCache.sizeKey == undefined) {
          latticeGridCache[sizeKey] = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[sizeKey]);
          var vbo_data = generateArbitraryDimensionLattice(geoScene.geoCastZSequence[i].size[0], geoScene.geoCastZSequence[i].size[1]);
          for (var i = 2, bc = 100; i < vbo_data.length; i += 3) { // Encode 100, 10, 1 as barycentric coords in the unused Z coord
            vbo_data[i] = bc;
            if (bc == 1)
              bc = 100;
            else
              bc /= 10;
          }
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
          latticeGridCache[sizeKey].n_of_vertices = vbo_data.length / 3; // Number of vertices to use
          gl.bindBuffer(gl.ARRAY_BUFFER, null);
        }
      }      
    }

    function generateArbitraryDimensionLattice(width, height) { // Generates a lattice of (width x height) vertices with
                                                                // normalized coords in the range [0;1]x[0;1]
      var vertices = new Float32Array(((2 * (width + 1 /* Last two for degenerate vertices*/)) * (height - 1)) * 3 /* xyz */ 
        - 2 * 3 /* Last row doesn't need the two degenerate vertices at the end */);
      var normalizeX = function(value) { // Normalize a value between [0;width] to the range [0;1]
        return value / width;
      }
      var normalizeY = function(value) { // Normalize a value between [0;height] to the range [0;1]
        return value / height;
      }
      for (var y = 0; y < height - 1; ++y) {
        // 1 -- 2
        // |  / |
        // | /  |
        // 5 -- 6

        var base_off = (y * (2 * (width + 1))) * 3;

        // Insert 1 and 5
        vertices[ base_off + 0 ] = normalizeX(0 + 0.5);
        vertices[ base_off + 1 ] = normalizeY(y + 0.5);
        vertices[ base_off + 2 ] = 0;

        vertices[ base_off + 3 ] = normalizeX(0 + 0.5);
        vertices[ base_off + 4 ] = normalizeY(y + 1.5);
        vertices[ base_off + 5 ] = 0;

        for (var x = 0; x < width - 1; ++x) {

           // Insert 2 and 6
           vertices[ base_off + ((x + 1 /* 1 and 5 are already in place */) * 2 * 3) + 0 ] = normalizeX(x + 1.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 1 ] = normalizeY(y + 0.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 2 ] = 0;

           vertices[ base_off + ((x + 1) * 2 * 3) + 3 ] = normalizeX(x + 1.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 4 ] = normalizeY(y + 1.5);
           vertices[ base_off + ((x + 1) * 2 * 3) + 5 ] = 0;
        }

        if (y < (height - 1) - 1) { // Do not insert the two degenerate points if we finished the last row

          // Insert two extra points to form degenerate triangles (end of row)
          vertices[ base_off + (width * 2 * 3) + 0 ] = vertices[ base_off + (width * 2 * 3) + 0 - 3 ];
          vertices[ base_off + (width * 2 * 3) + 1 ] = vertices[ base_off + (width * 2 * 3) + 1 - 3 ];
          vertices[ base_off + (width * 2 * 3) + 2 ] = vertices[ base_off + (width * 2 * 3) + 2 - 3 ];

          vertices[ base_off + (width * 2 * 3) + 3 ] = normalizeX(0 + 0.5); // Like 5
          vertices[ base_off + (width * 2 * 3) + 4 ] = normalizeY(y + 1.5);
          vertices[ base_off + (width * 2 * 3) + 5 ] = 0;
        }
      }
      return vertices;
    }

    var texturesMap = {};

    function loadTextures() {
      var loadTextureFromFile = function(geocastSequenceObject) {
        texturesMap[geocastSequenceObject.name] = [];
        for (var i = 0; i <= geoScene.sequence[1] - geoScene.sequence[0]; ++i) {
          texturesMap[geocastSequenceObject.name].push(new Object());
          texturesMap[geocastSequenceObject.name][i] = gl.createTexture();
          texturesMap[geocastSequenceObject.name][i].image = new Image();
          texturesMap[geocastSequenceObject.name][i].safeToRender = false;
          texturesMap[geocastSequenceObject.name][i].image.onload = (function (j) {
            var index = j;
            return function() {
              gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name][index]);
              gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texturesMap[geocastSequenceObject.name][index].image);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
              gl.bindTexture(gl.TEXTURE_2D, null);
              texturesMap[geocastSequenceObject.name][index].safeToRender = true;
            };
          })(i);
          texturesMap[geocastSequenceObject.name][i].image.src = geocastSequenceObject.image[i]; 
        }        
      };
      for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) {
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchSurfaceSequence,
          geoScene.geoCastZSequence, loadTextureFromFile, true);
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchCamSequence, 
          geoScene.geoCastSequence, loadTextureFromFile, true);
      }
    }

    var camera_frustum_lines_data;

    function setupGeometries() {
      camera_frustum_lines_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
      vbo_data = [
        1.0, 1.0, -1.0,
        1.0, 1.0, 1.0,
        -1.0, 1.0, -1.0,
        -1.0, 1.0, 1.0,
        1.0, -1.0, -1.0,
        1.0, -1.0, 1.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0, 1.0
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
      indices = [
        0, 1,
        4, 5,
        4, 0,
        5, 1,
        3, 2,
        7, 6,
        3, 7,
        2, 6,
        3, 1,
        2, 0,
        7, 5,
        6, 4
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices_length = indices.length;
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

      // Lattice data cannot be statically generated here - it depends on the image dimensions in the GeoScene (GeoCastZ, see @generateSceneLattices())
    }

    var cameraFrustumLinesProgram;
    var surfaceProgram;

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "camera-frustum-lines-shader-vs");
      var fragmentShader = getShader(gl, "camera-frustum-lines-shader-fs");
      cameraFrustumLinesProgram = gl.createProgram();
      gl.attachShader(cameraFrustumLinesProgram, vertexShader);
      gl.attachShader(cameraFrustumLinesProgram, fragmentShader);
      gl.linkProgram(cameraFrustumLinesProgram);
      if (!gl.getProgramParameter(cameraFrustumLinesProgram, gl.LINK_STATUS))
          console.log("Could not initialize shaders");
      gl.useProgram(cameraFrustumLinesProgram);
      cameraFrustumLinesProgram.aPosition = gl.getAttribLocation(cameraFrustumLinesProgram, "aPosition");      
      gl.enableVertexAttribArray(cameraFrustumLinesProgram.aPosition);
      cameraFrustumLinesProgram.uViewMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewMVMatrix");
      cameraFrustumLinesProgram.uViewProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix");
      cameraFrustumLinesProgram.uGeoCastProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix_Inverse");
      cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix_Inverse");
      cameraFrustumLinesProgram.uLineColor = gl.getUniformLocation(cameraFrustumLinesProgram, "uLineColor");
      
      vertexShader = getShader(gl, "surface-shader-vs");
      fragmentShader = getShader(gl, "surface-shader-fs");
      surfaceProgram = gl.createProgram();
      gl.attachShader(surfaceProgram, vertexShader);
      gl.attachShader(surfaceProgram, fragmentShader);
      gl.linkProgram(surfaceProgram);
      if (!gl.getProgramParameter(surfaceProgram, gl.LINK_STATUS))
          console.log("Could not initialize shaders");
      gl.useProgram(surfaceProgram);
      surfaceProgram.aPosition = gl.getAttribLocation(surfaceProgram, "aPosition");      
      gl.enableVertexAttribArray(surfaceProgram.aPosition);
      surfaceProgram.uViewMVMatrix = gl.getUniformLocation(surfaceProgram, "uViewMVMatrix");
      surfaceProgram.uViewProjMatrix = gl.getUniformLocation(surfaceProgram, "uViewProjMatrix");
      surfaceProgram.uFloorMVMatrix = gl.getUniformLocation(surfaceProgram, "uFloorMVMatrix");
      surfaceProgram.uFloorProjMatrix = gl.getUniformLocation(surfaceProgram, "uFloorProjMatrix");
      surfaceProgram.uFloorMVMatrix_Inverse = gl.getUniformLocation(surfaceProgram, "uFloorMVMatrix_Inverse");
      surfaceProgram.uFloorProjMatrix_Inverse = gl.getUniformLocation(surfaceProgram, "uFloorProjMatrix_Inverse");
      surfaceProgram.texDepthMapSampler = gl.getUniformLocation(surfaceProgram, "texDepthMapSampler");
      surfaceProgram.uFloorClipRange = gl.getUniformLocation(surfaceProgram, "uFloorClipRange");
      surfaceProgram.uGeocastMVPMatrix = gl.getUniformLocation(surfaceProgram, "uGeocastMVPMatrix");
      surfaceProgram.texGeocastSampler = gl.getUniformLocation(surfaceProgram, "texGeocastSampler[0]");
      surfaceProgram.uBoundSlots = gl.getUniformLocation(surfaceProgram, "uBoundSlots");
      surfaceProgram.uShowWireframe = gl.getUniformLocation(surfaceProgram, "uShowWireframe");
    }

    var projectionCenter = vec3.fromValues(0, 0, 0); // The center of the projection where the camera points at all times
    var theta = 200.0; // Degrees spherical coord
    var phi = 30.0;   // Degrees spherical coord
    var sphere_d = 100.0; // Start spherical distance
    var wireframeEnabled = false;

    var mouseDown = false;
    var mouseDownElementId;
    var lastMouseX = null;
    var lastMouseY = null;

    function setupInput(canvas) {
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it      
      canvas.onwheel = handleMouseWheel;
      document.onkeydown = handleKeyDown;
      canvas.addEventListener('touchstart', onTouchStart);
      canvas.addEventListener('touchmove', onTouchMove);
      canvas.addEventListener('touchend', onTouchEnd);
    }

    var touchFingers = {};
    var startZoomDistance = -1;

    function calculateTwoTouchPointsDistance() {
      var distance = -1;
      if (Object.keys(touchFingers).length == 2) { // Calculate starting zoom distance
        var points = [];
        for (var key in touchFingers) {
          var point = [touchFingers[key].startX, touchFingers[key].startY];
          points.push(point);
        }        
        distance = Math.sqrt(
                              Math.pow(points[0][0] - points[1][0], 2) +
                              Math.pow(points[0][1] - points[1][1], 2)
                            );
      }
      return distance;
    }

    function onTouchStart(event) {
      event.preventDefault();
      for (var i = 0; i < event.changedTouches.length; ++i) {
        var touch = event.changedTouches[i];
        touchFingers[touch.identifier] = {
          startX: parseInt(touch.clientX),
          startY: parseInt(touch.clientY)
        }
      }
      startZoomDistance = calculateTwoTouchPointsDistance();
    }

    function onTouchMove(event) {
      console.log("Touch move");      
      if (Object.keys(touchFingers).length == 1) {
        // Rotation
        var touch = touchFingers[event.changedTouches[0].identifier];
        if (touch == undefined)
          return;
        var newX = parseInt(event.changedTouches[0].clientX);
        var newY = parseInt(event.changedTouches[0].clientY);
        theta += (newX - touch.startX) / 10.0;
        phi += (newY - touch.startY) / 10.0;
        if (theta >= 360.0) // Take a look at handleMouseMove() for more information
          theta = theta % 360.0;
        if (theta < 0.0)
          theta += 360.0;
        if (phi > 90.0) phi = 90.0;
        if (phi < -90.0) phi = -90.0;
        touch.startX = newX;
        touch.startY = newY;
      } else if (Object.keys(touchFingers).length == 2) {
        // Zoom by pinching
        for (var i = 0; i < event.changedTouches.length; ++i) { // Update known points
          var touch = touchFingers[event.changedTouches[i].identifier];
          if (touch != undefined) {
            touch.startX = parseInt(event.changedTouches[i].clientX);
            touch.startY = parseInt(event.changedTouches[i].clientY);
          }
        }
        var newZoomDistance = calculateTwoTouchPointsDistance();
        sphere_d -= (newZoomDistance - startZoomDistance) / 10.0;
        startZoomDistance = newZoomDistance;
      }
    }

    function onTouchEnd(event) {
      for (var i = 0; i < event.changedTouches.length; ++i)
        delete touchFingers[event.changedTouches[i].identifier];
    }

    function handleKeyDown(event) {
      var key = event.keyCode || event.which;
      switch (key) {
        case 38: { // Up keyboard arrow -> ++matchgroup
          currentMatchGroup = Math.min(currentMatchGroup + 1, geoScene.matchGroupSequence.length - 1);
          document.getElementById("numberbox_matchgroup").value = currentMatchGroup;
        } break;
        case 40: { // Down keyboard arrow -> --matchgroup
          currentMatchGroup = Math.max(0, currentMatchGroup - 1);
          document.getElementById("numberbox_matchgroup").value = currentMatchGroup;
        } break;
        case 39: { // Right keyboard arrow -> ++frame
          var curFrame = currentSceneFrame + geoScene.sequence[0];
          curFrame = Math.min(curFrame + 1, geoScene.sequence[1]);
          document.getElementById("numberbox_frame").value = curFrame;
          currentSceneFrame = curFrame - geoScene.sequence[0];
        } break;
        case 37: { // Left keyboard arrow -> --frame
          var curFrame = currentSceneFrame + geoScene.sequence[0];
          curFrame = Math.max(geoScene.sequence[0], curFrame - 1);
          document.getElementById("numberbox_frame").value = curFrame;
          currentSceneFrame = curFrame - geoScene.sequence[0];
        } break;
        case 87: { // 'w' key for wireframe
          wireframeEnabled = !wireframeEnabled;
          document.getElementById("checkbox_wireframe").checked = wireframeEnabled;
        } break;
      }
    }

    function onMouseOutOfCanvas(event) {
      var e = event.toElement || event.relatedTarget;
      if (mouseDownElementId !== "canvas") // This is not handled for arrows
        return;
      handleMouseUp(event);
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.clientX;
      var newY = event.clientY;
      var deltaX = newX - lastMouseX;
      var deltaY = newY - lastMouseY;

      if (mouseDownElementId == "canvas") { // Canvas handling
        var d_theta = deltaX / 10.0;
        var d_phi   = deltaY / 10.0;

        theta += d_theta;
        if (theta >= 360.0) // Constrain theta in the [0;360] range
          theta = theta % 360.0;
        if (theta < 0.0)
          theta += 360.0; 
       
        phi += d_phi;
        if (phi > 90.0) phi = 90.0;   // Constrain phi in the [-90;90] range
        if (phi < -90.0) phi = -90.0; // to avoid up vector problems
      }

      lastMouseX = newX;
      lastMouseY = newY;
    }

    function handleMouseWheel(event) {
      // Get cross-browser wheel delta
      var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.deltaY || -event.detail)));
      //var delta = Math.max(-1, Math.min(1, event.wheelDelta));
 
      sphere_d += delta * -2.0;
    }

    function executeActionForObjectsInSequence(matchGroupSequence, geocastSequence, actionCallback, ignoreGeocast) {
      var orthoOrPerspMatrix = function(geocastObject) {
        return (geocastObject.PerspMatrix != undefined) ? 
                geocastObject.PerspMatrix : geocastObject.OrthoMatrix;
      }
      for (var objIndex in matchGroupSequence) {
        var objName = matchGroupSequence[objIndex];
        var geoCastSequenceObject = geocastSequence.find(function(element, index, array) {
          if(element.name == objName)
            return element;
        });
        if (geoCastSequenceObject == undefined || geoCastSequenceObject == null)
          console.log("Could not find a geocast sequence object with key '" + objName + "'");
        if (ignoreGeocast == false) {
          if (geoCastSequenceObject.geocast[currentSceneFrame] == undefined || 
              geoCastSequenceObject.geocast[currentSceneFrame] == null) {
            continue; // Sequence object not loaded yet
          }
          var pMatrix = orthoOrPerspMatrix(geoCastSequenceObject.geocast[currentSceneFrame]);
          actionCallback (geoCastSequenceObject, geoCastSequenceObject.geocast[currentSceneFrame].ModelviewMatrix, pMatrix);
        } else {
          actionCallback (geoCastSequenceObject);
        }
      }
    }

    function drawCameraFrustums() {
      var drawFrustum = function(mvMatrix, pMatrix, color) {
        var inverseMVMatrix = mat4.create();
        var inversePMatrix = mat4.create();
        mat4.invert(inverseMVMatrix, mvMatrix);
        mat4.invert(inversePMatrix, pMatrix);
        gl.useProgram(cameraFrustumLinesProgram);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
        gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
        gl.vertexAttribPointer(cameraFrustumLinesProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewMVMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewProjMatrix, false, perspectiveMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix, false, pMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse, false, inverseMVMatrix);      
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse, false, inversePMatrix);
        gl.uniform4fv(cameraFrustumLinesProgram.uLineColor, color);
        gl.drawElements(gl.LINES, camera_frustum_lines_data.indices_length, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }      
      // Gain all ZSequence objects and draw them
      var drawSurfaceFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) {
        drawFrustum (mvMatrix, pMatrix, [0.5, 0.5, 0.5, 1.0]);
      };
      executeActionForObjectsInSequence(
        geoScene.matchGroupSequence[currentMatchGroup].matchSurfaceSequence,
        geoScene.geoCastZSequence, drawSurfaceFrustumCallback, false);
      var drawCameraFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) {
        drawFrustum (mvMatrix, pMatrix, [0.8, 0.0, 0.0, 1.0]);
      };
      executeActionForObjectsInSequence(
        geoScene.matchGroupSequence[currentMatchGroup].matchCamSequence, 
        geoScene.geoCastSequence, drawCameraFrustumCallback, false);
    }

    function updateSceneMatrices() {
      mat4.identity(modelViewMatrix);
      mat4.identity(perspectiveMatrix);

      // Calculate camera position (eye field) according to spherical coords
      var cameraPos = vec3.create();
      cameraPos[0] = sphere_d * Math.sin(degToRad(theta)) * Math.cos(degToRad(phi));  
      cameraPos[1] = sphere_d * Math.cos(degToRad(theta)) * Math.cos(degToRad(phi));
      cameraPos[2] = sphere_d * Math.sin(degToRad(phi));

      mat4.lookAt(modelViewMatrix, /* eye */ cameraPos, /* center */ projectionCenter, /* up */ [0, 0, 1]);
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 5000.0);
    }

    function drawSurfaces() {

      var drawSurface = function(geocastSequenceObject /* ZSurface */, mvMatrix, pMatrix) {        
        gl.useProgram(surfaceProgram);
        
        if (texturesMap[geocastSequenceObject.name][currentSceneFrame].safeToRender == false)
          return;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name][currentSceneFrame]);
        gl.uniform1i(surfaceProgram.texDepthMapSampler, 0);

        var matricesFloatArray = [];
        var availableTexId = 1;
        var textureUnitsToUse = [];
        var textureKeys = [];
        var bindGeocastInfo = function(geocastSequenceObj, mvMat, pMat) {
          if (availableTexId > 15)
            console.log("Insufficient texture units");
          if(texturesMap[geocastSequenceObj.name][currentSceneFrame].safeToRender == false)
            return;
          var mvpMat = mat4.create();
          mat4.multiply(mvpMat, mvpMat, pMat);
          var mvInverseMat = mat4.create(); // (Marco): Remember that Geocarve uses inverted MVs
          mat4.invert(mvInverseMat, mvMat);
          mat4.multiply(mvpMat, mvpMat, mvInverseMat);
          matricesFloatArray.push.apply(matricesFloatArray, mvpMat);
          textureUnitsToUse.push(availableTexId);
          textureKeys.push(geocastSequenceObj.name);
          ++availableTexId;
        };
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[currentMatchGroup].matchCamSequence, 
          geoScene.geoCastSequence, bindGeocastInfo, false);

        if (textureUnitsToUse.length == 0)
          return; // Textures not loaded yet

        for (var i = 0; i < textureUnitsToUse.length; ++i) {
          gl.activeTexture(gl.TEXTURE0 + textureUnitsToUse[i]);
          gl.bindTexture(gl.TEXTURE_2D, texturesMap[textureKeys[i]][currentSceneFrame]);
        }
        gl.uniform1iv(surfaceProgram.texGeocastSampler, textureUnitsToUse);
        gl.uniformMatrix4fv(surfaceProgram.uGeocastMVPMatrix, false, matricesFloatArray);
        gl.uniform1fv(surfaceProgram.uBoundSlots, [textureUnitsToUse.length]);
        gl.uniform1fv(surfaceProgram.uShowWireframe, [wireframeEnabled == true ? 1.0 : 0.0]);
        
        var inverseMVMatrix = mat4.create();
        var inversePMatrix = mat4.create();
        mat4.invert(inverseMVMatrix, mvMatrix);
        mat4.invert(inversePMatrix, pMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorMVMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorProjMatrix, false, pMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorMVMatrix_Inverse, false, inverseMVMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uFloorProjMatrix_Inverse, false, inversePMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uViewMVMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(surfaceProgram.uViewProjMatrix, false, perspectiveMatrix);
        var zRange = (geocastSequenceObject.geocast[currentSceneFrame].ProjRange != undefined) ? 
                      geocastSequenceObject.geocast[currentSceneFrame].ProjRange : geocastSequenceObject.geocast[currentSceneFrame].ClipRange;
        gl.uniform2fv(surfaceProgram.uFloorClipRange, zRange);

        var resKey = geocastSequenceObject.size[0] + 'x' + geocastSequenceObject.size[1];
        if (Object.keys(latticeGridCache).length == 0 || latticeGridCache[resKey] == undefined)
          return; // Lattice hasn't been created yet / object not ready
        gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[resKey]);
        gl.vertexAttribPointer(surfaceProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, latticeGridCache[resKey].n_of_vertices);
        
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      };
      executeActionForObjectsInSequence(
        geoScene.matchGroupSequence[currentMatchGroup].matchSurfaceSequence, 
        geoScene.geoCastZSequence, drawSurface, false);
    }

    function drawScene() {
      if (geoScene == null)
        return; // Still loading..

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

      updateSceneMatrices();
      drawCameraFrustums();
      drawSurfaces();
    }

    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }

    // UI related routines
    function handleWireframeClick(checkbox) {
      wireframeEnabled = checkbox.checked;
    }

    function handleMatchgroupChange(inputbox) {
      var rangeCheckedValue = Math.max(0, Math.min(geoScene.matchGroupSequence.length - 1, inputbox.value));
      currentMatchGroup = rangeCheckedValue;
      inputbox.value = rangeCheckedValue;
      inputbox.setAttribute('value', rangeCheckedValue);
      console.log("fired handleMatchgroupChange: " + rangeCheckedValue);
    }

    function handleFrameChange(inputbox) {      
      var rangeCheckedValue = Math.max(geoScene.sequence[0], Math.min(geoScene.sequence[1], inputbox.value));
      currentSceneFrame = rangeCheckedValue - geoScene.sequence[0];
      inputbox.value = rangeCheckedValue;
      inputbox.setAttribute('value', rangeCheckedValue);
      console.log("fired handleFrameChange: " + rangeCheckedValue);
    }
  </script>
<body onload="webGLStart();" onresize="onResizeCanvas();">
  <div class="content-div">
    <div class="header">
      <div class="logo">
        <img src="img/geofront.svg" class="geofront-img"/>
        <div id="label">Geocarve Viewer</div>
      </div>
    </div>
    <div id="canvasContainer" class="container">
      <div id="controlsDiv">
        <label for="wireframe_checkbox" class="aligncheckbox"><input type="checkbox" id="checkbox_wireframe" class="aligncheckbox" onclick="handleWireframeClick(this);"/><span>&nbsp;Toggle Wireframe</span></label><br/>
        <p>MatchGroup <span id="rangeMatchgroup">[]</span>&nbsp;&nbsp;<input id="numberbox_matchgroup" class="numberbox" type="number" value="1" min="1" max="999" onchange="handleMatchgroupChange(this);"/></p>
        <p>Frame <span id="rangeFrame">[]</span>&nbsp;&nbsp;<input id="numberbox_frame" class="numberbox" type="number" value="1" min="1" max="999" onchange="handleFrameChange(this);"/></p>
      </div>
      <canvas id="canvas"></canvas>
    </div>    
    <div class="footer">
      <div class="geofront-credits">
        <a class="hvr-underline-from-left" href="http://www.geofront.eu/"> Â© geofront e.U. - All rights reserved </a>
      </div>
    </div>
  </div>
</body>
</html>