<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Geocarve WebGL Viewer</title>
  <script type="text/javascript" src="utils/js-geoscene-reader/gl-matrix-min.js"></script>
  <script type="text/javascript" src="utils/js-geoscene-reader/geoscene-filereader.js"></script>
  <script type="text/javascript" src="utils/webgl-utils.js"></script>
  <script type="text/javascript" src="utils/webgl-debug.js"></script>  
</head>
<script id="camera-frustum-lines-shader-fs" type="x-shader/x-fragment">
  precision highp float;

  uniform vec4 uLineColor;

  void main(void) {
    gl_FragColor = uLineColor;
  }
</script>
<script id="camera-frustum-lines-shader-vs" type="x-shader/x-vertex">
  precision highp float;
  attribute vec3 aPosition;

  uniform mat4 uViewMVMatrix;
  uniform mat4 uViewProjMatrix;

  uniform mat4 uGeoCastMVMatrix;
  uniform mat4 uGeoCastProjMatrix;
  uniform mat4 uGeoCastMVMatrix_Inverse;
  uniform mat4 uGeoCastProjMatrix_Inverse;
  uniform vec2 uGeoCastClipRange;

  void main(void) {
    gl_Position = uViewProjMatrix * uViewMVMatrix * (uGeoCastMVMatrix * uGeoCastProjMatrix_Inverse *  vec4(aPosition.xyz, 1.0));
  }
</script>
<script type="text/javascript">
    var gl; // gl instance

    // Global scene matrices
    var perspectiveMatrix = mat4.create();
    var modelViewMatrix = mat4.create();
    
    var geoScene = null; // Main GeoScene object
    var currentMatchGroup = 0; // Current matchgroup index
    
    function webGLStart() {
      var canvas = document.getElementById("canvas");
      try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      } catch (e) {}
      if (!gl) {
        console.log("Could not initialize WebGL");
      }

      setupGeometries();
      setupShaderPrograms();
      setupInput(canvas);

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);

      var geoSceneObjectReady = function(object) {
        geoScene = object;
      };      
      readGeoSceneFile("data/set0.geoscene", geoSceneObjectReady); // DEBUG - Local path for tests
      
      paintLoop();
    }

    var camera_frustum_lines_data;

    function setupGeometries() {
      camera_frustum_lines_data = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
      vbo_data = [
        1.0, 1.0, -1.0,
        1.0, 1.0, 1.0,
        -1.0, 1.0, -1.0,
        -1.0, 1.0, 1.0,
        1.0, -1.0, -1.0,
        1.0, -1.0, 1.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0, 1.0
      ];
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
      indices = [
        0, 1,
        4, 5,
        4, 0,
        5, 1,
        3, 2,
        7, 6,
        3, 7,
        2, 6,
        3, 1,
        2, 0,
        7, 5,
        6, 4
      ];
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      camera_frustum_lines_data.indices_length = indices.length;
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    var cameraFrustumLinesProgram;

    function setupShaderPrograms() {      
      var vertexShader = getShader(gl, "camera-frustum-lines-shader-vs");
      var fragmentShader = getShader(gl, "camera-frustum-lines-shader-fs");
      cameraFrustumLinesProgram = gl.createProgram();
      gl.attachShader(cameraFrustumLinesProgram, vertexShader);
      gl.attachShader(cameraFrustumLinesProgram, fragmentShader);
      gl.linkProgram(cameraFrustumLinesProgram);
      if (!gl.getProgramParameter(cameraFrustumLinesProgram, gl.LINK_STATUS))
          console.log("Could not initialize shaders");
      gl.useProgram(cameraFrustumLinesProgram);
      // Bind uniforms and attributes      
      cameraFrustumLinesProgram.uViewMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewMVMatrix");
      cameraFrustumLinesProgram.uViewProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uViewProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix");
      cameraFrustumLinesProgram.uGeoCastProjMatrix = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix");
      cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastMVMatrix_Inverse");
      cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse = gl.getUniformLocation(cameraFrustumLinesProgram, "uGeoCastProjMatrix_Inverse");
      cameraFrustumLinesProgram.uLineColor = gl.getUniformLocation(cameraFrustumLinesProgram, "uLineColor");
      cameraFrustumLinesProgram.aPosition = gl.getAttribLocation(cameraFrustumLinesProgram, "aPosition");      
      gl.enableVertexAttribArray(cameraFrustumLinesProgram.aPosition);
    }

    var projectionCenter = vec3.fromValues(0, 0, 0); // The center of the projection where the camera points at all times
    var theta = 200.0; // Degrees spherical coord
    var phi = 30.0;   // Degrees spherical coord
    var sphere_d = 500.0; // Start spherical distance

    var mouseDown = false;
    var mouseDownElementId;
    var lastMouseX = null;
    var lastMouseY = null;

    function setupInput(canvas) {
      canvas.onmousedown = handleMouseDown;
      canvas.onmouseup = handleMouseUp;
      canvas.onmousemove = handleMouseMove;
      canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it
      canvas.onwheel = handleMouseWheel;
    }

    function onMouseOutOfCanvas(event) {
      var e = event.toElement || event.relatedTarget;
      if (mouseDownElementId !== "canvas") // This is not handled for arrows
        return;
      handleMouseUp(event);
    }

    function handleMouseDown(event) {
      mouseDown = true;
      // Get element id (cross-browser friendly) where mouse was pressed
      mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
      mouseDownElementId = null;
    }

    function handleMouseMove(event) {
      
      if(!mouseDown)
        return;

      var newX = event.clientX;
      var newY = event.clientY;
      var deltaX = newX - lastMouseX;
      var deltaY = newY - lastMouseY;

      if (mouseDownElementId == "canvas") { // Canvas handling
        var d_theta = deltaX / 10.0;
        var d_phi   = deltaY / 10.0;

        theta += d_theta;
        if (theta >= 360.0) // Constrain theta in the [0;360] range
          theta = theta % 360.0;
        if (theta < 0.0)
          theta += 360.0; 
       
        phi += d_phi;
        if (phi > 90.0) phi = 90.0;   // Constrain phi in the [-90;90] range
        if (phi < -90.0) phi = -90.0; // to avoid up vector problems
      }

      lastMouseX = newX;
      lastMouseY = newY;
    }

    function handleMouseWheel(event) {
      // Get cross-browser wheel delta
      var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.deltaY || -event.detail)));
      //var delta = Math.max(-1, Math.min(1, event.wheelDelta));
 
      sphere_d += delta * -2.0;
    }

    function drawCameraFrustums() {
      var drawFrustum = function(mvMatrix, pMatrix, color) {
        var inverseMVMatrix = mat4.create();
        var inversePMatrix = mat4.create();
        mat4.invert(inverseMVMatrix, mvMatrix);
        mat4.invert(inversePMatrix, pMatrix);
        gl.useProgram(cameraFrustumLinesProgram);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
        gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
        gl.vertexAttribPointer(cameraFrustumLinesProgram.aPosition, 3, gl.FLOAT, false, 0, 0);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewMVMatrix, false, modelViewMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uViewProjMatrix, false, perspectiveMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix, false, mvMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix, false, pMatrix);
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastMVMatrix_Inverse, false, inverseMVMatrix);      
        gl.uniformMatrix4fv(cameraFrustumLinesProgram.uGeoCastProjMatrix_Inverse, false, inversePMatrix);
        gl.uniform4fv(cameraFrustumLinesProgram.uLineColor, color);
        gl.drawElements(gl.LINES, camera_frustum_lines_data.indices_length, gl.UNSIGNED_SHORT, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }
      var orthoOrPerspMatrix = function(geocastObject) {
        return (geocastObject.PerspMatrix != undefined) ? 
                geocastObject.PerspMatrix : geocastObject.OrthoMatrix;
      }
      var drawSequenceObjects = function(matchGroupSequence, geocastSequence, color) {
        for (var objIndex in matchGroupSequence) {
          var objName = matchGroupSequence[objIndex];
          var geoCastSequenceObject = geocastSequence.find(function(element, index, array) {
            if(element.name == objName)
              return element;
          });
          if (geoCastSequenceObject.geocast == undefined || geoCastSequenceObject.geocast == null) {
            continue; // Sequence object not loaded yet
          }
          var pMatrix = orthoOrPerspMatrix(geoCastSequenceObject.geocast);
          drawFrustum (geoCastSequenceObject.geocast.ModelviewMatrix, pMatrix, color);
        }
      }
      // Gain all ZSequence objects and draw them
      drawSequenceObjects(geoScene.matchGroupSequence[currentMatchGroup].matchSurfaceSequence, 
                          geoScene.geoCastZSequence, [0.5, 0.5, 0.5, 1.0]);

      drawSequenceObjects(geoScene.matchGroupSequence[currentMatchGroup].matchCamSequence, 
                          geoScene.geoCastSequence, [0.8, 0.0, 0.0, 1.0]);
    }

    function updateSceneMatrices() {
      mat4.identity(modelViewMatrix);
      mat4.identity(perspectiveMatrix);

      // Calculate camera position (eye field) according to spherical coords
      var cameraPos = vec3.create();
      cameraPos[0] = sphere_d * Math.sin(degToRad(theta)) * Math.cos(degToRad(phi));  
      cameraPos[1] = sphere_d * Math.cos(degToRad(theta)) * Math.cos(degToRad(phi));
      cameraPos[2] = sphere_d * Math.sin(degToRad(phi));

      mat4.lookAt(modelViewMatrix, /* eye */ cameraPos, /* center */ projectionCenter, /* up */ [0, 0, 1]);
      mat4.perspective(perspectiveMatrix, degToRad(45), gl.viewportWidth / gl.viewportHeight, 0.1, 5000.0);
    }

    function drawScene() {
      if (geoScene == null)
        return; // Still loading..

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

      updateSceneMatrices();

      // Draw all camera frustums
      drawCameraFrustums();
    }

    function paintLoop() {
      requestAnimFrame(paintLoop);
      drawScene();
    }
  </script>
<body onload="webGLStart();">
  <canvas id="canvas"  width="1200" height="800"></canvas>
</body>
</html>