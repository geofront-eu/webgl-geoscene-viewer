<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>geocast viewer - WebGL</title>
    <meta name="description" content="GeoCast in WebGL">
    <meta name="keywords" content="geofront,geocarve,geoscene,geocast,online,webgl,viewer">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    
    <link href="css/style.css" rel="stylesheet">
    
    
    <script src="utils/glsl.js"></script>
    <script type="text/javascript" src="utils/js-geoscene-reader/gl-matrix-min.js"></script>
    <script type="text/javascript" src="utils/js-geoscene-reader/geoscene-filereader.js"></script>
<!--    <script type="text/javascript" src="utils/webgl-utils.js"></script> -->
<!--    <script type="text/javascript" src="utils/webgl-debug.js"></script> --> 
  </head>
  
<script type="text/javascript">

"use strict";

var gl; // WebGL context
var canvas;

// Global scene matrices
var perspectiveMatrix = mat4.create();
var modelViewMatrix = mat4.create();

var geoScene = null; // Main GeoScene object
var currentMatchGroups = {}; // Active matchgroups
var currentSceneFrame = 0; // Current geoscene frame (0 maps to geoScene.sequence[0])

var framePerFrameLoading = true; // Whether to load textures every time a frame asks for them or
// load ALL of the needed textures in a single asynchronous bulk loading

function webGLStart() 
{
  canvas = document.getElementById("canvas");
  var canvasContainer = document.getElementById("canvasContainer");      
  try {
    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    canvas.width = canvasContainer.offsetWidth;
    canvas.height = canvasContainer.offsetHeight;
  } catch (e) {}
  if (!gl) {
    console.log("Could not initialize WebGL");
  }
  gl.getExtension('OES_standard_derivatives');
  
  setupGeometries();
  setupShaderPrograms();
  setupFramebuffers();
  setupInput(canvas);
  
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  gl.enable(gl.DEPTH_TEST);
  
  var geoSceneObjectReady = function(object) {
    updateLoadingProgress("Geoscene Loaded", 100);
    geoScene = object;
    currentSceneFrame = 0; // 0 maps to geoScene.sequence[0];        
    
    var frameCtrl = document.getElementById("numberbox_frame");
    frameCtrl.min = geoScene.sequence[0];
    frameCtrl.max = geoScene.sequence[1];
    frameCtrl.value = geoScene.sequence[0];
    document.getElementById("rangeFrame").innerHTML = "[" + geoScene.sequence[0] + ";" + geoScene.sequence[1] + "]";
    var matchgroupsDiv = document.getElementById("matchgroups_div");
    var divHtml = "";
    for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) {
      divHtml += "<label for=\"matchgroup_checkbox_" + i + "\" class=\"aligncheckbox\"><input type=\"checkbox\" " +
        "id=\"matchgroup_checkbox_" + i + "\" class=\"aligncheckbox\" onclick=\"handleMatchgroupClick(this, " + i + ");\"><span>&nbsp;MatchGroup " +
        i + "</span></label><br/>";
    }
    matchgroupsDiv.innerHTML = divHtml;
    
    if (geoScene.matchGroupSequence.length > 0)
          activateMatchgroup(0, true);
    
    generateSceneLattices();
    if (framePerFrameLoading == false)
      loadTextures();
    else
      loadTexturesForFrame(currentSceneFrame);
  };
  
  updateLoadingProgress("Reading GeoScene", 10);
  readGeoSceneFile("data/sedan/sedan.geoscene", geoSceneObjectReady); // DEBUG - Local path for tests
  //readGeoSceneFile("data/20160318_street_camviews_on_proxy/scene.geoscene", geoSceneObjectReady); // DEBUG - Local path for tests
  //readGeoSceneFile("data/20160428_arch_sweep/scene.geoscene", geoSceneObjectReady); // DEBUG - Local path for tests
  
  paintLoop();
}

function onResizeCanvas() 
{
  var canvasContainer = document.getElementById("canvasContainer");
  canvas.width = canvasContainer.offsetWidth;
  canvas.height = canvasContainer.offsetHeight;
  gl.canvas.width = canvas.width;
  gl.canvas.height = canvas.height;
  setupFramebuffers(); // Resize secondary framebuffers
}

function getCurrentMatchgroup() 
{
  return currentMatchGroup;
}

function increaseFrameWithBoundsChecking() 
{ 
  // Returns the new geoscene-range frame
  var curGeosceneFrame = currentSceneFrame + geoScene.sequence[0];
  curGeosceneFrame = Math.min(curGeosceneFrame + 1, geoScene.sequence[1]);
  currentSceneFrame = curGeosceneFrame - geoScene.sequence[0];
  
  if (framePerFrameLoading)
    loadTexturesForFrame(currentSceneFrame);
  
  return curGeosceneFrame;
}

function decreaseFrameWithBoundsChecking() 
{ 
  var curGeosceneFrame = currentSceneFrame + geoScene.sequence[0];
  curGeosceneFrame = Math.max(geoScene.sequence[0], curGeosceneFrame - 1);
  currentSceneFrame = curGeosceneFrame - geoScene.sequence[0];
  
  if (framePerFrameLoading)
    loadTexturesForFrame(currentSceneFrame);
  
  return curGeosceneFrame;
}

function setFrameWithBoundsChecking(value) 
{ 
  var rangeCheckedValue = Math.max(geoScene.sequence[0], Math.min(geoScene.sequence[1], value));
  currentSceneFrame = rangeCheckedValue - geoScene.sequence[0];
  
  if (framePerFrameLoading)
    loadTexturesForFrame(currentSceneFrame);
  
  return rangeCheckedValue;
}

function getCurrentFrameInGeosceneRange() 
{ 
  return currentSceneFrame + geoScene.sequence[0];// Returns the geoscene-range frame
}

var latticeGridCache = {}; // A cache for different resolution lattices

function generateSceneLattices() 
{
  updateLoadingProgress("Generating Grids", 0);
  for (var i = 0; i < geoScene.geoCastZSequence.length; ++i) 
  {
    var sizeKey = geoScene.geoCastZSequence[i].size[0] + 'x' + geoScene.geoCastZSequence[i].size[1];

    if (latticeGridCache.sizeKey == undefined) 
    {
      latticeGridCache[sizeKey] = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[sizeKey]);
      latticeGridCache[sizeKey].width = geoScene.geoCastZSequence[i].size[0];
      latticeGridCache[sizeKey].height = geoScene.geoCastZSequence[i].size[1];
      var vbo_data = generateArbitraryDimensionLattice(geoScene.geoCastZSequence[i].size[0], geoScene.geoCastZSequence[i].size[1]);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
      latticeGridCache[sizeKey].n_of_vertices = vbo_data.length /4; // 4 floats per vertex
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }

    updateLoadingProgress("Generating Grids", 100 * ((i + 1) / geoScene.geoCastZSequence.length));
  }

  updateLoadingProgress("Grids Ready", 100);
}

function generateArbitraryDimensionLattice(width, height) 
{ 
  var V = []; // 4 triangles to cover triangle in all potential turning directions

  for (var y = 0; y < height - 1; y++) 
    for (var x = 0; x < width - 1; x++) 
  {
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(0.0);      V.push(0.0);   //  00-10 : Triangle type 0 
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(1.0);      V.push(0.0);   //  | /
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(0.1);      V.push(0.0);   //  01

    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(1.0);      V.push(1.0);   //     10 : Triangle type 1 
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(1.1);      V.push(1.0);   //    / |
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(0.1);      V.push(1.0);   //  01-11

    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(0.0);      V.push(2.0);   //  00-10 : Triangle type 2
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(1.0);      V.push(2.0);   //    \ |
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(1.1);      V.push(2.0);   //     11

    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(0.0);      V.push(3.0);   //  00    : Triangle type 3
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(1.1);      V.push(3.0);   //  | \
    V.push((x + 0.5)/width);    V.push((y + 0.5)/height);    V.push(0.1);      V.push(3.0);   //  01-11
  }

  return V;
}


var texturesMap = {};
var totalNumberOfTextures = 0;
var loadedTextures = 0;

function updateLoadingProgress(text, value, finalize) 
{
  document.getElementById("loadingDiv").style.display = '';
  document.getElementById("loadingText").innerHTML = text;
  document.getElementById("loadingBar").value = value;
  if (finalize != undefined && finalize == true && value == 100) {
    document.getElementById("loadingText").innerHTML = "Viewer Ready";
    setTimeout(hideLoadingProgress, 3000);
  }
}

function hideLoadingProgress() 
{
  document.getElementById("loadingDiv").style.display = 'none';
}

var alreadyLoadedFrame = {};

function loadTexturesForFrame(frame) 
{
  if (alreadyLoadedFrame[frame] != undefined && alreadyLoadedFrame[frame] == true)
    console.log("Already loaded this frame I think?");

  if (frame == currentSceneFrame) // Only update progress bar if still in the current frame
    updateLoadingProgress("Readying Requests", 0);
  
  var loadTextureFromFileForCurrentFrame = 
    (
      function (frame) 
      {
        var storedFrame = frame;
        return function(geocastSequenceObject) 
	{
	  console.log("Loading NOW textures for file " + geocastSequenceObject.name);
	  
          if (texturesMap[geocastSequenceObject.name] == undefined)
            texturesMap[geocastSequenceObject.name] = {};
          
	  var textureIndex = storedFrame;
          if (geocastSequenceObject.image.length == 1)
            textureIndex = 0; // Deals with the 1-texture only case
          if(texturesMap[geocastSequenceObject.name][textureIndex] != undefined) 
	  {
            if (storedFrame == currentSceneFrame) // Only update progress bar if still in the current frame
              updateLoadingProgress("Loading Textures", 100 * (++loadedTextures / totalNumberOfTextures), true);
            return; // Already in memory
          }
	  
          texturesMap[geocastSequenceObject.name][textureIndex] = gl.createTexture();
          texturesMap[geocastSequenceObject.name][textureIndex].image = new Image();
          texturesMap[geocastSequenceObject.name][textureIndex].safeToRender = false;
          texturesMap[geocastSequenceObject.name][textureIndex].image.onload = 
	    (function (j, f) 
	     {
	       var index = j;
	       var frameWhichRequestedLoading = f;
	       return function() 
	       {
		 gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name][index]);
		 gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texturesMap[geocastSequenceObject.name][index].image);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		 gl.bindTexture(gl.TEXTURE_2D, null);
		 texturesMap[geocastSequenceObject.name][index].safeToRender = true;
		 if (frameWhichRequestedLoading == currentSceneFrame) // Only update progress bar if still in the current frame
                   updateLoadingProgress("Loading Textures", 100 * (++loadedTextures / totalNumberOfTextures), true);
	       };
             })(textureIndex, storedFrame);
          texturesMap[geocastSequenceObject.name][textureIndex].image.src = geocastSequenceObject.image[textureIndex];     
        }
      });

      loadedTextures = 0;
      totalNumberOfTextures = 0;
      var isSequenceObjectUsed = {}; // Allows fast usage checking for a sequence object

      for(var groupId in currentMatchGroups) 
      {
        //if (currentMatchGroups[groupId] == false) continue;

        geoScene.matchGroupSequence[groupId].matchSurfaceSequence.forEach(function(entry) { isSequenceObjectUsed[entry] = true; });
        geoScene.matchGroupSequence[groupId].matchCamSequence.forEach(function(entry) { isSequenceObjectUsed[entry] = true; });
      
        geoScene.geoCastSequence.forEach(function(entry) {
          if (isSequenceObjectUsed[entry.name] == true)
            totalNumberOfTextures += 1;
        });
        geoScene.geoCastZSequence.forEach(function(entry) {
          if (isSequenceObjectUsed[entry.name] == true)
            totalNumberOfTextures += 1;
        });
      }
      if (frame == currentSceneFrame) // Only update progress bar if still in the current frame
        updateLoadingProgress("Loading Textures", 0);
      for(var groupId in currentMatchGroups) {
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[groupId].matchSurfaceSequence,
          geoScene.geoCastZSequence, loadTextureFromFileForCurrentFrame(frame), true);
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[groupId].matchCamSequence, 
          geoScene.geoCastSequence, loadTextureFromFileForCurrentFrame(frame), true);
      }

      alreadyLoadedFrame[frame] = true;
    }

function loadTextures() 
{
  updateLoadingProgress("Readying Requests", 0);

  var loadTextureFromFile = function(geocastSequenceObject) 
  {
    if (texturesMap[geocastSequenceObject.name] != undefined) return;
    texturesMap[geocastSequenceObject.name] = [];
    var numberOfTextures = geoScene.sequence[1] - geoScene.sequence[0] + 1; // Both bounds inclusive
    if (geocastSequenceObject.image.length == 1)
      numberOfTextures = 1; // Deals with the 1-texture only case
    for (var i = 0; i < numberOfTextures; ++i) 
    {
      texturesMap[geocastSequenceObject.name].push(new Object());
      texturesMap[geocastSequenceObject.name][i] = gl.createTexture();
      texturesMap[geocastSequenceObject.name][i].image = new Image();
      texturesMap[geocastSequenceObject.name][i].safeToRender = false;
      texturesMap[geocastSequenceObject.name][i].image.onload = 
	(function (j) {
          var index = j;
          return function() {
            gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name][index]);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texturesMap[geocastSequenceObject.name][index].image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.bindTexture(gl.TEXTURE_2D, null);
            texturesMap[geocastSequenceObject.name][index].safeToRender = true;
            updateLoadingProgress("Loading Textures", 100 * (++loadedTextures / totalNumberOfTextures), true);
          };
        })(i);          
      texturesMap[geocastSequenceObject.name][i].image.src = geocastSequenceObject.image[i]; 
    }        
  };

  var isSequenceObjectUsed = {}; // Allows fast usage checking for a sequence object
  for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) 
  {
    geoScene.matchGroupSequence[i].matchSurfaceSequence.forEach(function(entry) {  isSequenceObjectUsed[entry] = true; });
    geoScene.matchGroupSequence[i].matchCamSequence.forEach(function(entry) { isSequenceObjectUsed[entry] = true;});
  }

      totalNumberOfTextures = 0;
      loadedTextures = 0;
      geoScene.geoCastSequence.forEach(function(entry) {
        if (isSequenceObjectUsed[entry.name] == true)
          totalNumberOfTextures += entry.image.length;
      });
      geoScene.geoCastZSequence.forEach(function(entry) {
        if (isSequenceObjectUsed[entry.name] == true)
          totalNumberOfTextures += entry.image.length;
      });
      updateLoadingProgress("Loading Textures", 0);
      for (var i = 0; i < geoScene.matchGroupSequence.length; ++i) 
  {
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchSurfaceSequence,
          geoScene.geoCastZSequence, loadTextureFromFile, true);
        executeActionForObjectsInSequence(
          geoScene.matchGroupSequence[i].matchCamSequence, 
          geoScene.geoCastSequence, loadTextureFromFile, true);
      }
}

var camera_frustum_lines_data;

function setupGeometries() 
{
  camera_frustum_lines_data = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
  var vbo_data = [
      +1.0, 1.0, -1.0,
      +1.0, 1.0, 1.0,
      -1.0, 1.0, -1.0,
      -1.0, 1.0, 1.0,
      +1.0, -1.0, -1.0,
      +1.0, -1.0, 1.0,
      -1.0, -1.0, -1.0,
      -1.0, -1.0, 1.0
  ];
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vbo_data), gl.STATIC_DRAW);
  camera_frustum_lines_data.indices = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
  var indices = [
    0, 1,        4, 5,        4, 0,        5, 1,
    3, 2,        7, 6,        3, 7,        2, 6,
    3, 1,        2, 0,        7, 5,        6, 4
  ];
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  camera_frustum_lines_data.indices_length = indices.length;
  camera_frustum_lines_data.triangle_indices = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.triangle_indices);
  var indices = [
    0, 1, 4,        4, 1, 5,        // Left
    3, 2, 7,        7, 2, 6,        // Right
    6, 2, 0,        6, 0, 4,        // near plane
    6, 4, 7,        7, 4, 5,        // bottom
    2, 3, 1,        2, 1, 0,        // up
    5, 1, 3,        5, 3, 7         // far plane
  ];
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
  camera_frustum_lines_data.triangle_indices_length = indices.length;
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  
  // Note: Lattice data cannot be statically generated here - it depends on the image dimensions in the GeoScene (GeoCastZ, see @generateSceneLattices())
}


var glsl_programs = 
[ { name: "camera_frustum_lines", vertex_src:['glsl/camera_frustum_lines.vert.glsl'], fragment_src: ['glsl/camera_frustum_lines.frag.glsl']},
  { name: "colorpicker", vertex_src:['glsl/colorpicker.vert.glsl'], fragment_src: ['glsl/colorpicker.frag.glsl']},
  { name: "surface", vertex_src:['glsl/surface.vert.glsl'], fragment_src: ['glsl/surface.frag.glsl']},
];

function setupShaderPrograms() 
{      
  glsl_load(gl, glsl_programs);
}
  
var colorPickerFramebuffer;
var colorPickerRenderTexture;

function setupFramebuffers() 
{
  // Init secondary framebuffer for color picking
  colorPickerFramebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, colorPickerFramebuffer);
  colorPickerFramebuffer.width = gl.canvas.width;
  colorPickerFramebuffer.height = gl.canvas.height;
  // This is the only texture that is set up here because related to the framebuffer
  colorPickerRenderTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, colorPickerRenderTexture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);        
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, colorPickerFramebuffer.width, colorPickerFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  // Attach the texture to the framebuffer
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorPickerRenderTexture, 0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

var projectionCenter = vec3.fromValues(0, 0, 0); // The center of the projection where the camera points at all times
var theta = 200.0; // Degrees spherical coord
var phi = 30.0;   // Degrees spherical coord
var sphere_d = 100.0; // Start spherical distance
var wireframeEnabled = false;
var noTimelineOnFrustums = false;

var mouseDown = false;
var mouseDownElementId;
var mouseDownAction = null; // Either "RotateScene" or "TimelineDrag"
var dragDeltas = 0; // Accumulates timeline drag deltas from the mouse (allows a smoother scroll)
var lastMouseX = null;
var lastMouseY = null;

function setupInput(canvas) 
{
  canvas.onmousedown = handleMouseDown;
  canvas.onmouseup = handleMouseUp;
  canvas.onmousemove = handleMouseMove;
  canvas.addEventListener('mouseout', onMouseOutOfCanvas, true); // Stop canvas input if mouse gets out of it      
  canvas.onwheel = handleMouseWheel;
  document.onkeydown = handleKeyDown;
  canvas.addEventListener('touchstart', onTouchStart);
  canvas.addEventListener('touchmove', onTouchMove);
  canvas.addEventListener('touchend', onTouchEnd);
}

var touchFingers = {};
var startZoomDistance = -1;

function calculateTwoTouchPointsDistance() 
{
  var distance = -1;
  if (Object.keys(touchFingers).length == 2) { // Calculate starting zoom distance
    var points = [];
    for (var key in touchFingers) {
      var point = [touchFingers[key].startX, touchFingers[key].startY];
      points.push(point);
    }        
    distance = Math.sqrt(
      Math.pow(points[0][0] - points[1][0], 2) +
        Math.pow(points[0][1] - points[1][1], 2)
    );
  }
  return distance;
}

function getOffsetXY(e) 
{ // Workaround for unsupported offsetX/offsetY (not yet standardized)
  var getCumulativeOffset = function(child) {
    var x = 0, y = 0;
    while (child && !isNaN(child.offsetLeft) && !isNaN(child.offsetTop)) {
      x += child.offsetLeft - child.scrollLeft;
      y += child.offsetTop - child.scrollTop;
      child = child.offsetParent;
    }
    return { top: y, left: x };
  };      
  if(e.offsetX == undefined) { // Slower but more compatible
    var coffs = getCumulativeOffset(canvas);
    return { top: e.pageY - coffs.top, left: e.pageX - coffs.left };
  }
  else
    return { top: e.offsetY, left: e.offsetX };
}

function onTouchStart(event) {
  event.preventDefault();
  for (var i = 0; i < event.changedTouches.length; ++i) {
    var touch = event.changedTouches[i];
    var offXY = getOffsetXY(touch);
    touchFingers[touch.identifier] = {
      startX: parseInt(offXY.left),
      startY: parseInt(offXY.top)
    };
    mouseDownAction = "RotateScene";
    if (noTimelineOnFrustums == false) {
      var timelineClick = executeColorPicking(offXY.left, offXY.top);
      if (timelineClick)
        mouseDownAction = "TimelineDrag";
    }
  }
  startZoomDistance = calculateTwoTouchPointsDistance();
}

function onTouchMove(event) {
  if (Object.keys(touchFingers).length == 1) {
    
    var touch = touchFingers[event.changedTouches[0].identifier];
    if (touch == undefined)
      return;
    
    var offXY = getOffsetXY(event.changedTouches[0]);
    var newX = parseInt(offXY.left);
    var newY = parseInt(offXY.top);
    
    if (mouseDownAction == "RotateScene") { // Rotation
      
      theta += (newX - touch.startX) / 10.0;
      phi += (newY - touch.startY) / 10.0;

          if (theta >= 360.0) // Take a look at handleMouseMove() for more information
            theta = theta % 360.0;
          if (theta < 0.0)
            theta += 360.0;
          if (phi > 90.0) phi = 90.0;
          if (phi < -90.0) phi = -90.0;

        } else if (mouseDownAction == "TimelineDrag") { // Timeline dragging handling

          var deltaX = newX - touch.startX;
          if(deltaX > 0) // Only use deltaX here
            ++dragDeltas;
          else if(deltaX < 0)
            --dragDeltas;

          if (dragDeltas > 5) {
            increaseFrameWithBoundsChecking();
            updateFrameEditBox(getCurrentFrameInGeosceneRange());
            dragDeltas = 0;
          } else if (dragDeltas < -5) {
            decreaseFrameWithBoundsChecking();
            updateFrameEditBox(getCurrentFrameInGeosceneRange());
            dragDeltas = 0;
          }

        }

        touch.startX = newX;
        touch.startY = newY;

      } else if (Object.keys(touchFingers).length == 2) { // Zoom by pinching

        for (var i = 0; i < event.changedTouches.length; ++i) { // Update known points
          var touch = touchFingers[event.changedTouches[i].identifier];
          if (touch != undefined) {
            var offXY = getOffsetXY(event.changedTouches[i]);
            touch.startX = parseInt(offXY.left);
            touch.startY = parseInt(offXY.top);
          }
        }

        var newZoomDistance = calculateTwoTouchPointsDistance();
        sphere_d -= (newZoomDistance - startZoomDistance) / 10.0;
        startZoomDistance = newZoomDistance;
      }
    }

    function onTouchEnd(event) {
      for (var i = 0; i < event.changedTouches.length; ++i)
        delete touchFingers[event.changedTouches[i].identifier];
    }

    function handleKeyDown(event) {
      var key = event.keyCode || event.which;
      switch (key) {
        case 39: { // Right keyboard arrow -> ++frame
          document.getElementById("numberbox_frame").value = increaseFrameWithBoundsChecking();
        } break;
        case 37: { // Left keyboard arrow -> --frame
          document.getElementById("numberbox_frame").value = decreaseFrameWithBoundsChecking();
        } break;
        case 87: { // 'w' key for wireframe
          wireframeEnabled = !wireframeEnabled;
          document.getElementById("checkbox_wireframe").checked = wireframeEnabled;
        } break;
      }
    }

function onMouseOutOfCanvas(event) 
{
  var e = event.toElement || event.relatedTarget;
  if (mouseDownElementId !== "canvas") // This is not handled for arrows
    return;
  handleMouseUp(event);
}

function handleMouseDown(event) 
{
  mouseDown = true;
  // Get element id (cross-browser friendly) where mouse was pressed
  mouseDownElementId = event.target ? event.target.id : event.srcElement.id;
  
  var offXY = getOffsetXY(event);
  lastMouseX = offXY.left;
  lastMouseY = offXY.top;
  
  mouseDownAction = "RotateScene";
  if (noTimelineOnFrustums == false) 
  {
    var timelineClick = executeColorPicking(lastMouseX, lastMouseY);
    if (timelineClick)
      mouseDownAction = "TimelineDrag";
  }
}

function handleMouseUp(event) 
{
  mouseDown = false;
  mouseDownElementId = null;
}

function handleMouseMove(event) 
{  
  if(!mouseDown)
    return;
  
  var offXY = getOffsetXY(event);
  var newX = offXY.left;
  var newY = offXY.top;
  var deltaX = newX - lastMouseX;
  var deltaY = newY - lastMouseY;
  
  if (mouseDownElementId == "canvas")  
  {
    if (mouseDownAction == "RotateScene")  
    {
      var d_theta = deltaX / 10.0;
      var d_phi   = deltaY / 10.0;
      
      theta += d_theta;
      if (theta >= 360.0) // Constrain theta in the [0;360] range
        theta = theta % 360.0;
      if (theta < 0.0)
        theta += 360.0; 
      
      phi += d_phi;
      if (phi > 90.0) phi = 90.0;   // Constrain phi in the [-90;90] range
      if (phi < -90.0) phi = -90.0; // to avoid up vector problems
      
    } 
    else if (mouseDownAction == "TimelineDrag") 
    { 
      // Only use deltaX here
      if(deltaX > 0)       ++dragDeltas;
      else if(deltaX < 0)  --dragDeltas;

      if (dragDeltas > 5) 
      {
        increaseFrameWithBoundsChecking();
        updateFrameEditBox(getCurrentFrameInGeosceneRange());
        dragDeltas = 0;
      } 
      else 
	if (dragDeltas < -5) 
      {
        decreaseFrameWithBoundsChecking();
        updateFrameEditBox(getCurrentFrameInGeosceneRange());
            dragDeltas = 0;
      }
      
    }
  }

  lastMouseX = newX;
  lastMouseY = newY;
}

function handleMouseWheel(event) 
{
  // Get cross-browser wheel delta
  var delta = Math.max(-1, Math.min(1, (event.wheelDelta || -event.deltaY || -event.detail)));
  //var delta = Math.max(-1, Math.min(1, event.wheelDelta));
  
  sphere_d += delta * -2.0;
}

function executeColorPicking(mouseX, mouseY) 
{  
  updateSceneMatrices();
  
  gl.bindFramebuffer(gl.FRAMEBUFFER, colorPickerFramebuffer);      
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
  var sh = glsl_programs.colorpicker;   gl.useProgram(sh);

  gl.uniformMatrix4fv(sh.uniforms.uViewMVMatrix, false, modelViewMatrix);
  gl.uniformMatrix4fv(sh.uniforms.uViewProjMatrix, false, perspectiveMatrix);
  
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.triangle_indices);
  gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
  gl.vertexAttribPointer(glsl_programs.camera_frustum_lines.attributes.aPosition, 3, gl.FLOAT, false, 0, 0);
  
  var baseColor = [1.0, 0.0, 0.0, 1.0];
  
  var drawColorFrustum = function(geocastSequenceObject, mvMatrix, pMatrix) 
  {
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastMVMatrix, false, mvMatrix);
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastProjMatrix, false, pMatrix);

    var inverseMVMatrix = mat4.create();
    var inversePMatrix = mat4.create();
    mat4.invert(inverseMVMatrix, mvMatrix);
    mat4.invert(inversePMatrix, pMatrix);
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastMVMatrix_Inverse, false, inverseMVMatrix);      
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastProjMatrix_Inverse, false,inversePMatrix);
    
    gl.uniform4fv(sh.uniforms.uColor, baseColor);

    gl.drawElements(gl.TRIANGLES, camera_frustum_lines_data.triangle_indices_length, gl.UNSIGNED_SHORT, 0);
  };
  
  for(var groupId in currentMatchGroups) 
  {
    if (currentMatchGroups[groupId] == false)
      continue;
    executeActionForObjectsInSequence(
      geoScene.matchGroupSequence[groupId].matchCamSequence,
      geoScene.geoCastSequence, drawColorFrustum, false);
    executeActionForObjectsInSequence(
      geoScene.matchGroupSequence[groupId].matchSurfaceSequence,
      geoScene.geoCastZSequence, drawColorFrustum, false);
  }

  // Detect the sequence object associated to where the mouse clicked
  var pixel_data = new Uint8Array(4);
  
  // Remember that coordinates are upside down for pixel readbacks
  gl.readPixels(mouseX, gl.canvas.height - mouseY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel_data);
  
  // Restore original framebuffer
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  
  return (pixel_data[0] != 0); // Timeline
}

function executeActionForObjectsInSequence(matchGroupSequence, geocastSequence, actionCallback, ignoreGeocast) 
{
  var orthoOrPerspMatrix = function(geocastObject) 
  {
    return (geocastObject.PerspMatrix != undefined) ? 
      geocastObject.PerspMatrix : geocastObject.OrthoMatrix;
  }

  for (var objIndex in matchGroupSequence) 
  {
    var objName = matchGroupSequence[objIndex];
    var geoCastSequenceObject = geocastSequence.find(function(element, index, array) {
      if(element.name == objName)
        return element;
    });
    if (geoCastSequenceObject == undefined || geoCastSequenceObject == null)
      console.log("Could not find a geocast sequence object with key '" + objName + "'");
    if (ignoreGeocast == false) {
      var index = currentSceneFrame;
      // console.log(geoCastSequenceObject.geocast);
      //console.log("geocastseq length is " + geoCastSequenceObject.geocast.length);
      
      if (geoCastSequenceObject.geocast.length == 1)
      {
	// console.log("Length is only 1");
        index = 0; // Deals with only one geocast case
      }
      //console.log("Examining geocat at index" + index + ":" + geoCastSequenceObject.geocast[index]);
      
      if (geoCastSequenceObject.geocast[index].ModelviewMatrix == undefined || 
          geoCastSequenceObject.geocast[index].ModelviewMatrix == null) { // Caveat: do NOT check for the object itself (placeholders)
          continue; // Sequence object not loaded yet
      }
      var pMatrix = orthoOrPerspMatrix(geoCastSequenceObject.geocast[index]);
      actionCallback (geoCastSequenceObject, geoCastSequenceObject.geocast[index].ModelviewMatrix, pMatrix);
    } else {
      actionCallback (geoCastSequenceObject);
    }
  }
}

function drawCameraFrustums() 
{
  var drawFrustum = function(mvMatrix, pMatrix, color) 
  {
    var inverseMVMatrix = mat4.create();
    var inversePMatrix = mat4.create();
    mat4.invert(inverseMVMatrix, mvMatrix);
    mat4.invert(inversePMatrix, pMatrix);

    var sh = glsl_programs.camera_frustum_lines;     gl.useProgram(sh);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, camera_frustum_lines_data.indices);
    gl.bindBuffer(gl.ARRAY_BUFFER, camera_frustum_lines_data);
    gl.vertexAttribPointer(sh.attributes.aPosition, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(sh.attributes.aPosition);   
    gl.uniformMatrix4fv(sh.uniforms.uViewMVMatrix, false, modelViewMatrix);
    gl.uniformMatrix4fv(sh.uniforms.uViewProjMatrix, false, perspectiveMatrix);
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastMVMatrix, false, mvMatrix);
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastProjMatrix, false, pMatrix);
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastMVMatrix_Inverse, false, inverseMVMatrix);      
    gl.uniformMatrix4fv(sh.uniforms.uGeoCastProjMatrix_Inverse, false, inversePMatrix);
    gl.uniform4fv(sh.uniforms.uLineColor, color);
    gl.drawElements(gl.LINES, camera_frustum_lines_data.indices_length, gl.UNSIGNED_SHORT, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
  }
  
  var drawSurfaceFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) 
  { drawFrustum (mvMatrix, pMatrix, [0.5, 0.5, 0.5, 1.0]); }; // Z surfaces
      
  var drawCameraFrustumCallback = function(geocastSequenceObject, mvMatrix, pMatrix) 
  {  drawFrustum (mvMatrix, pMatrix, [0.8, 0.0, 0.0, 1.0]);      };

  for(var groupId in currentMatchGroups) 
  {
    if (currentMatchGroups[groupId] == false)
      continue;

    executeActionForObjectsInSequence(
      geoScene.matchGroupSequence[groupId].matchSurfaceSequence,
      geoScene.geoCastZSequence, drawSurfaceFrustumCallback, false);

    executeActionForObjectsInSequence(
      geoScene.matchGroupSequence[groupId].matchCamSequence,
      geoScene.geoCastSequence, drawCameraFrustumCallback, false);
  }
}

function updateSceneMatrices() 
{
  mat4.identity(modelViewMatrix);
  mat4.identity(perspectiveMatrix);
  
  // Calculate camera position (eye field) according to spherical coords
  var cameraPos = vec3.create();
  cameraPos[0] = sphere_d * Math.sin(degToRad(theta)) * Math.cos(degToRad(phi));  
  cameraPos[1] = sphere_d * Math.cos(degToRad(theta)) * Math.cos(degToRad(phi));
  cameraPos[2] = sphere_d * Math.sin(degToRad(phi));
  
  mat4.lookAt(modelViewMatrix, /* eye */ cameraPos, /* center */ projectionCenter, /* up */ [0, 0, 1]);
  mat4.perspective(perspectiveMatrix, degToRad(45), gl.canvas.width / gl.canvas.height, 0.1, 5000.0);
}

var maximumCamTexturesEverBound = 0;

function drawSurfaces() 
{      
  var drawSurface = function (id) 
  {
    var matchGroupId = id;
    return function(geocastSequenceObject /* ZSurface */, mvMatrix, pMatrix) 
    {        
      //console.log("drawSurface object function call for "  + geocastSequenceObject.name); 

      var sh = glsl_programs.surface;      
      gl.useProgram(sh);

      //if (texturesMap == undefined) console.log("texturesMap undefined!");
      //if (texturesMap[geocastSequenceObject.name] == undefined) console.log("texturesMap for this object undefined!");
      
      var depthTextureFrameIndex = currentSceneFrame;
      if (geocastSequenceObject.image.length == 1)
            depthTextureFrameIndex = 0;
      
      //if (texturesMap[geocastSequenceObject.name][depthTextureFrameIndex] == undefined ||
      //    texturesMap[geocastSequenceObject.name][depthTextureFrameIndex].safeToRender == false)        return;
      var resKey = geocastSequenceObject.size[0] + 'x' + geocastSequenceObject.size[1];

      //if (Object.keys(latticeGridCache).length == 0 || latticeGridCache[resKey] == undefined)
      //  return; // Lattice hasn't been created yet / object not ready
      
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texturesMap[geocastSequenceObject.name][depthTextureFrameIndex]);
      gl.uniform1i(sh.uniforms.texDepthMapSampler, 0);

      var matricesFloatArray = [];
      var availableTexId = 1;
      var textureUnitsToUse = [];
      var textureKeys = [];
      var detectedUnsafeToRenderTextures = false;
      var cameraNameToCurrentIndex = {};
      var bindGeocastInfo = function(geocastSequenceObj, mvMat, pMat) 
      {
        if (availableTexId > 15)
          console.log("Insufficient texture units");
        var projectiveTextureFrameIndex = currentSceneFrame;
        if (geocastSequenceObj.image.length == 1)
          projectiveTextureFrameIndex = 0;
        cameraNameToCurrentIndex[geocastSequenceObj.name] = projectiveTextureFrameIndex;
        if(texturesMap[geocastSequenceObj.name][projectiveTextureFrameIndex].safeToRender == false) 
	{
          detectedUnsafeToRenderTextures = true;
          return;
        }
        var mvpMat = mat4.create();
        mat4.multiply(mvpMat, mvpMat, pMat);
        var mvInverseMat = mat4.create(); // (Marco): Remember that Geocarve uses inverted MVs
        mat4.invert(mvInverseMat, mvMat);
        mat4.multiply(mvpMat, mvpMat, mvInverseMat);
        matricesFloatArray.push.apply(matricesFloatArray, mvpMat);
        textureUnitsToUse.push(availableTexId);
        textureKeys.push(geocastSequenceObj.name);
        ++availableTexId;
      };
      executeActionForObjectsInSequence(
        geoScene.matchGroupSequence[matchGroupId].matchCamSequence, 
        geoScene.geoCastSequence, bindGeocastInfo, false);
      
      if (textureUnitsToUse.length == 0 || detectedUnsafeToRenderTextures == true)
			  { console.log("Textures not loaded yet!"); return; }
      
      for (var i = 0; i < textureUnitsToUse.length; ++i) 
      {
        gl.activeTexture(gl.TEXTURE0 + textureUnitsToUse[i]);
        var projectiveTextureFrameIndex = cameraNameToCurrentIndex[textureKeys[i]];
        //if (texturesMap[textureKeys[i]][projectiveTextureFrameIndex].safeToRender == false) return;
        gl.bindTexture(gl.TEXTURE_2D, texturesMap[textureKeys[i]][projectiveTextureFrameIndex]);
      }

      var shaderTextureUnitsArray = textureUnitsToUse;
      if (shaderTextureUnitsArray.length < maximumCamTexturesEverBound) { // Workaround for chrome unbound texunit warnings
        Array.prototype.push.apply(shaderTextureUnitsArray, new Uint8Array(maximumCamTexturesEverBound - shaderTextureUnitsArray.length));
      } else if (shaderTextureUnitsArray.length > maximumCamTexturesEverBound) {
        maximumCamTexturesEverBound = shaderTextureUnitsArray.length;
      }

      // this is broken (glsl.js should do this, but cant handle array uniforms!)
      //sh.uniforms.texGeocastSampler = gl.getUniformLocation(sh, "texGeocastSampler[0]");   
      //sh.uniforms.uGeocastMVPMatrix = gl.getUniformLocation(sh, "uGeocastMVPMatrix[0]");   

      gl.uniform1iv(sh.uniforms.texGeocastSampler, shaderTextureUnitsArray);
      gl.uniformMatrix4fv(sh.uniforms.uGeocastMVPMatrix, false, matricesFloatArray);

      gl.uniform1f(sh.uniforms.uBoundSlots, textureUnitsToUse.length);
      gl.uniform1f(sh.uniforms.uShowWireframe, wireframeEnabled == true ? 1.0 : 0.0);
      
      var inverseMVMatrix = mat4.create();
      var inversePMatrix = mat4.create();
      mat4.invert(inverseMVMatrix, mvMatrix);
      mat4.invert(inversePMatrix, pMatrix);
      gl.uniformMatrix4fv(sh.uniforms.uFloorMVMatrix, false, mvMatrix);
      gl.uniformMatrix4fv(sh.uniforms.uFloorProjMatrix, false, pMatrix);
      gl.uniformMatrix4fv(sh.uniforms.uFloorMVMatrix_Inverse, false, inverseMVMatrix);
      gl.uniformMatrix4fv(sh.uniforms.uFloorProjMatrix_Inverse, false, inversePMatrix);
      gl.uniformMatrix4fv(sh.uniforms.uViewMVMatrix, false, modelViewMatrix);
      gl.uniformMatrix4fv(sh.uniforms.uViewProjMatrix, false, perspectiveMatrix);
      
      var geocastFrameIndex = currentSceneFrame;
      if (geocastSequenceObject.geocast.length == 1)
        geocastFrameIndex = 0;
      
      var zRange = (geocastSequenceObject.geocast[geocastFrameIndex].ProjRange != undefined) ? 
        geocastSequenceObject.geocast[geocastFrameIndex].ProjRange : geocastSequenceObject.geocast[geocastFrameIndex].ClipRange;
      gl.uniform2fv(sh.uniforms.uFloorClipRange, zRange);
       
      gl.bindBuffer(gl.ARRAY_BUFFER, latticeGridCache[resKey]);
      gl.vertexAttribPointer(sh.attributes.aPosition, 4, gl.FLOAT, false, 0, 0);
      
      gl.uniform2f(sh.uniforms.delta, 1.0/latticeGridCache[resKey].width, 1.0/latticeGridCache[resKey].height);
      
      gl.drawArrays(gl.TRIANGLES, 0, latticeGridCache[resKey].n_of_vertices);
      //      console.log("Drawing " + latticeGridCache[resKey].n_of_vertices + " vertices as triangles for lattice.");
      
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, null);
      for (var i = 0; i < textureUnitsToUse.length; ++i) 
      {
        gl.activeTexture(gl.TEXTURE0 + textureUnitsToUse[i]);
        gl.bindTexture(gl.TEXTURE_2D, null);
      }
      gl.useProgram(null);
    };
  };

  for(var groupId in currentMatchGroups) 
  {
    if (currentMatchGroups[groupId] == false)
      continue;

    executeActionForObjectsInSequence(
      geoScene.matchGroupSequence[groupId].matchSurfaceSequence,
      geoScene.geoCastZSequence, drawSurface(groupId), false);
  }
}

function drawScene() 
{
  if (geoScene == null) return; // Still loading..
  
  if (glsl_programs.ready)
  {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

    updateSceneMatrices();
    drawCameraFrustums();
    drawSurfaces();
  }

}

function paintLoop() 
{
  requestAnimationFrame(paintLoop);
  drawScene();
}

// UI related routines
function activateMatchgroup(id, activate) 
{
  if (activate) 
  {
    console.log("Activating matchgroup " + id);

    document.getElementById("matchgroup_checkbox_" + id).checked = true;
    currentMatchGroups[id] = true;
    loadTexturesForFrame(currentSceneFrame);
  } else {
    document.getElementById("matchgroup_checkbox_" + id).checked = false;
    currentMatchGroups[id] = false;
  }
}

function handleWireframeClick(checkbox) 
{
  wireframeEnabled = checkbox.checked;
}

function deactivateTimelineClick(checkbox) 
{
  noTimelineOnFrustums = checkbox.checked;
}

function handleMatchgroupClick(checkbox, id) 
{
  activateMatchgroup(id, checkbox.checked);
}

function handleFrameChange(inputbox) 
{
  var newValue;

  if (inputbox.value == '')
    newValue = geoScene.sequence[0];
  else 
  {
    newValue = parseInt(inputbox.value);
    if (newValue == NaN)
      newValue = geoScene.sequence[0];
  }

  var rangeCheckedValue = setFrameWithBoundsChecking(newValue);
  inputbox.value = rangeCheckedValue;
}

function updateFrameEditBox(value) 
{
  document.getElementById("numberbox_frame").value = value;
}

</script>

<body onload="webGLStart();" onresize="onResizeCanvas();">
  <div class="content-div">
    <div class="header">
      <img src="img/geofront.svg" class="geofront-img"/>
    </div>
    <div id="canvasContainer" class="container">
      <div id="controlsDiv">
        <label for="wireframe_checkbox" class="aligncheckbox"><input type="checkbox" id="checkbox_wireframe" class="aligncheckbox" onclick="handleWireframeClick(this);"/><span>&nbsp;Toggle Wireframe</span></label><br/>
        <label for="deactivatetimeline_checkbox" class="aligncheckbox"><input type="checkbox" id="deactivatetimeline_checkbox" class="aligncheckbox" onclick="deactivateTimelineClick(this);"/><span>&nbsp;No Frustum Scroll</span></label><br/>
        <p>Frame <span id="rangeFrame">[]</span>&nbsp;&nbsp;<input id="numberbox_frame" class="numberbox" type="number" value="0" min="0" max="999" onchange="handleFrameChange(this);"/></p>
    <p>(Timestep: Arrowkey left/right)
        <p>Active MatchGroups<br/><div id="matchgroups_div"></div></p>        
      </div>
      <div id="loadingDiv"><label for="loadingBar"><span id="loadingText"></span>&nbsp;&nbsp;<progress id="loadingBar" value="0" max="100"></progress></label></div>
      <canvas id="canvas"></canvas>
    </div>    
    <div class="footer">
      <div class="geofront-credits">
        <div id="label">geocast viewer - WebGL</div>
      </div>
    </div>
  </div>
</body>
</html>
